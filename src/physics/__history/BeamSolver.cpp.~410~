//---------------------------------------------------------------------------

 
#pragma hdrstop

#include "BeamSolver.h"
// #include "Types.h"

//---------------------------------------------------------------------------
__fastcall TBeamSolver::TBeamSolver(AnsiString UserIniPath)
{
    this->UserIniPath = UserIniPath;
    Initialize();
}
//---------------------------------------------------------------------------
__fastcall TBeamSolver::TBeamSolver()
{
    Initialize();
}
//---------------------------------------------------------------------------
__fastcall TBeamSolver::~TBeamSolver()
{
    delete[] StructPar.Cells;
    delete[] Structure;

    for (int i=0;i<Npoints;i++)
        delete Beam[i];
    delete[] Beam;

    delete[] Par;
    for (int i=0;i<Ncoef;i++)
        delete[] K[i];
    delete[] K;

    #ifndef RSLINAC
    if (SmartProgress!=NULL)
        delete SmartProgress;
    #endif

    delete InputStrings;
    delete ParsedStrings;

    //fclose(logFile);
}
//---------------------------------------------------------------------------
void TBeamSolver::Initialize()
{
    MaxCells=500;
    Nmesh=20;
    Kernel=0.9;
    SplineType=LSPLINE;
    Nstat=100;
    Ngraph=500;
    Nbars=100;
    Nav=10;
    Smooth=0.95;
    Npoints=1;

	//Np=1;
   //	NpEnergy=0;
	Np_beam=1;
	BeamPar.RBeamType=NOBEAM;
	BeamPar.ZBeamType=NOBEAM;
	BeamPar.NParticles=1;
	BeamPar.Magnetized=false;

	StructPar.NSections=0;
	StructPar.Sections=NULL;
	StructPar.NElements=0;
	StructPar.ElementsLimit=-1;

	LoadIniConstants();

	DataReady=false;
	Stop=false;

	K=new TIntegration*[Ncoef];
	for (int i=0;i<Ncoef;i++)
		K[i]=new TIntegration[BeamPar.NParticles];

	Par=new TIntParameters[Ncoef];

	StructPar.Cells = new TCell[1];

    Beam=new TBeam*[Npoints];
    for (int i=0;i<Npoints;i++) {
        Beam[i]=new TBeam(1);
    }

    Structure=new TStructure[Npoints];

    InputStrings=new TStringList;
    ParsedStrings=new TStringList;

    #ifndef RSLINAC
    SmartProgress=NULL;
    #endif
}
//---------------------------------------------------------------------------
void TBeamSolver::ResetStructure()
{
	StructPar.NSections=0;
	if (StructPar.Sections!=NULL) {
		delete[] StructPar.Sections;
		StructPar.Sections=NULL;
	}
	StructPar.NElements=0;
	if (StructPar.Cells!=NULL) {
		delete[] StructPar.Cells;
		StructPar.Cells=NULL;
	}
}
//---------------------------------------------------------------------------
void TBeamSolver::ShowError(AnsiString &S)
{
	ShowMessage(S);
	ParsedStrings->Add(S);
}
//---------------------------------------------------------------------------
void TBeamSolver::SaveToFile(AnsiString& Fname)
{
    FILE *F;
    F=fopen(Fname.c_str(),"wb");

    fwrite(&Npoints,sizeof(int),1,F);
	fwrite(&BeamPar.NParticles,sizeof(int),1,F);
    fwrite(&Nbars,sizeof(int),1,F);

    fwrite(Structure,sizeof(TStructure),Npoints,F);

    for(int i=0;i<Npoints;i++){
        fwrite(&(Beam[i]->lmb),sizeof(double),1,F);
        fwrite(&(Beam[i]->h),sizeof(double),1,F);
        fwrite(&(Beam[i]->Ib),sizeof(double),1,F);
        fwrite(&(Beam[i]->I0),sizeof(double),1,F);
		fwrite(Beam[i]->Particle,sizeof(TParticle),BeamPar.NParticles,F);
    }

    fclose(F);
}
//---------------------------------------------------------------------------
bool TBeamSolver::LoadFromFile(AnsiString& Fname)
{
    FILE *F;
    F=fopen(Fname.c_str(),"rb");
    bool Success;

    delete[] Structure;

    for (int i=0;i<Np_beam;i++)
        delete Beam[i];
    delete[] Beam;

    Beam=new TBeam*[Npoints];
    for (int i=0;i<Npoints;i++)
		Beam[i]=new TBeam(BeamPar.NParticles);
	Np_beam=Npoints;

    try{
        fread(&Npoints,sizeof(int),1,F);
		fread(&BeamPar.NParticles,sizeof(int),1,F);
        fread(&Nbars,sizeof(int),1,F);

        Structure=new TStructure[Npoints];
        Beam=new TBeam*[Npoints];
        for (int i=0;i<Npoints;i++)
			Beam[i]=new TBeam(BeamPar.NParticles);

        fread(Structure,sizeof(TStructure),Npoints,F);
      //    fread(Beam,sizeof(TBeam),Npoints,F);


        for (int i=0;i<Npoints;i++){
            fread(&(Beam[i]->lmb),sizeof(double),1,F);
            fread(&(Beam[i]->h),sizeof(double),1,F);
            fread(&(Beam[i]->Ib),sizeof(double),1,F);
            fread(&(Beam[i]->I0),sizeof(double),1,F);
			fread(Beam[i]->Particle,sizeof(TParticle),BeamPar.NParticles,F);
        }
        Success=true;
    } catch (...){
        Success=false;
    }

    fclose(F);
    return Success;
}
//---------------------------------------------------------------------------
#ifndef RSLINAC
void TBeamSolver::AssignSolverPanel(TObject *SolverPanel)
{
    SmartProgress=new TSmartProgress(static_cast <TWinControl *>(SolverPanel));
}
#endif
//---------------------------------------------------------------------------
void TBeamSolver::LoadIniConstants()
{
    TIniFile *UserIni;
    int t;
    double stat;

    UserIni=new TIniFile(UserIniPath);
    MaxCells=UserIni->ReadInteger("OTHER","Maximum Cells",MaxCells);
    Nmesh=UserIni->ReadInteger("NUMERIC","Number of Mesh Points",Nmesh);
    Kernel=UserIni->ReadFloat("Beam","Percent Of Particles in Kernel",Kernel);
    if (Kernel>0)
    	Kernel/=100;
    	else
    	Kernel=0.9;

    
    t=UserIni->ReadInteger("NUMERIC","Spline Interpolation",t);
    switch (t) {
        case (0):{
            SplineType=LSPLINE;
            break;
        }
        case (1):{
            SplineType=CSPLINE;
            break;
        }
        case (2):{
            SplineType=SSPLINE;
            break;
        }
    }

    stat=UserIni->ReadFloat("NUMERIC","Statistics Error",stat);
    if (stat<1e-6)
        stat=1e-6;
    if (stat>25)
        stat=25;
	int Nstat=round(100.0/stat);
	AngErr=UserIni->ReadFloat("NUMERIC","Angle Error",AngErr);
    Smooth=UserIni->ReadFloat("NUMERIC","Smoothing",Smooth);
    Ngraph=UserIni->ReadInteger("OTHER","Chart Points",Nbars);
    Nbars=UserIni->ReadInteger("NUMERIC","Hystogram Bars",Ngraph);
    Nav=UserIni->ReadInteger("NUMERIC","Averaging Points",Nav);
}
//---------------------------------------------------------------------------
int TBeamSolver::GetNumberOfPoints()
{
    return Npoints;
}
/*//---------------------------------------------------------------------------
double TBeamSolver::GetWaveLength()
{
    return lmb;
} */
//---------------------------------------------------------------------------
int TBeamSolver::GetMeshPoints()
{
    return Nmesh;
}
//---------------------------------------------------------------------------
int TBeamSolver::GetNumberOfParticles()
{
	return BeamPar.NParticles;
}
//---------------------------------------------------------------------------
int TBeamSolver::GetNumberOfChartPoints()
{
    return Ngraph;
}
//---------------------------------------------------------------------------
int TBeamSolver::GetNumberOfBars()
{
    return Nbars;
}
//---------------------------------------------------------------------------
int TBeamSolver::GetNumberOfCells()
{
	return -1;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetFrequency()
{
	return -1;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetPower()
{
	return -1;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputCurrent()
{
	return BeamPar.Current;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputAverageEnergy()
{
	return Beam[0]->GetAverageEnergy();
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputEnergyDeviation()
{
	return -1;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputAveragePhase()
{
	return Beam[0]->GetAveragePhase();
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputPhaseDeviation()
{
	return -1;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputAlpha()
{
	return -1;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputBetta()
{
	return -1;
}
//---------------------------------------------------------------------------
double TBeamSolver::GetInputEpsilon()
{
	return -1;
}
//---------------------------------------------------------------------------
bool TBeamSolver::CheckMagnetization()
{
	return BeamPar.Magnetized;
}
//---------------------------------------------------------------------------
bool TBeamSolver::CheckReverse()
{
	return StructPar.Reverse;
}
//---------------------------------------------------------------------------
TSpaceCharge TBeamSolver::GetSpaceChargeInfo()
{
	return BeamPar.SpaceCharge;
}
//---------------------------------------------------------------------------
TMagnetParameters TBeamSolver::GetSolenoidInfo()
{
	return StructPar.SolenoidPar;
}
//---------------------------------------------------------------------------
bool TBeamSolver::IsKeyWord(AnsiString &S)
{
    return S=="POWER" ||
        S=="SOLENOID" ||
        S=="BEAM" ||
        S=="CURRENT" ||
        S=="DRIFT" ||
        S=="CELL" ||
		S=="CELLS" ||
		S=="SAVE" ||
        S=="OPTIONS" ||
		S=="SPCHARGE"; 
	  //	S=="COMMENT";
}
//---------------------------------------------------------------------------
TBeamType TBeamSolver::ParseDistribution(AnsiString &S)
{
	 TBeamType D=NOBEAM;
		if (S=="CST_PID")
			D=CST_PID;
		else if (S=="CST_PIT")
			D=CST_PIT;
		else if (S=="TWISS2D")
			D=TWISS_2D;
		else if (S=="TWISS4D")
			D=TWISS_4D;
		else if (S=="SPH2D")
			D=SPH_2D;
		else if (S=="ELL2D")
			D=ELL_2D;
		else if (S=="FILE1D")
			D=FILE_1D;
		else if (S=="FILE2D")
			D=FILE_2D;
		else if (S=="FILE4D")
			D=FILE_4D;
		else if (S=="NORM2D")
			D=NORM_2D;
		/*else if (S=="NORM4D")
			D=NORM_4D;  */
	 return D;
}
//---------------------------------------------------------------------------
bool TBeamSolver::IsFullFileKeyWord(TBeamType D)
{
	bool R=false;

	switch (D) {
		case CST_PID:{}
		case CST_PIT:{R=true;break;}
		default: R=false;
	}
	return R;
}
//---------------------------------------------------------------------------
bool TBeamSolver::IsTransverseKeyWord(TBeamType D)
{
	bool R=false;

	switch (D) {
		case TWISS_2D:{}
		case TWISS_4D:{}
		case FILE_2D:{}
		case FILE_4D:{}
		case TWO_FILES_2D:{}
		case SPH_2D:{}
		case ELL_2D:{R=true;break;}
		default: R=false;
	}
	return R;
}
//---------------------------------------------------------------------------
bool TBeamSolver::IsLongitudinalKeyWord(TBeamType D)
{
	bool R=false;

	switch (D) {
		case FILE_1D:{}
		case FILE_2D:{}
		case NORM_2D:{R=true;break;}
		default: R=false;
	}
	return R;
}
//---------------------------------------------------------------------------
bool TBeamSolver::IsFileKeyWord(TBeamType D)
{
	bool R=false;

	switch (D) {
        case CST_PID:{}
		case CST_PIT: {}
		case FILE_1D:{}
		case FILE_2D:{}
		case TWO_FILES_2D:{}
		case FILE_4D:{R=true;break;}
		default: R=false;
	}
	return R;
}
//---------------------------------------------------------------------------
TInputParameter TBeamSolver::Parse(AnsiString &S)
{
    TInputParameter P;
    FILE *logFile;
	
/*    logFile=fopen("BeamSolver.log","a");
    fprintf(logFile,"Parse: S=%s\n",S);
    fclose(logFile); */
	if (S=="POWER")
		P=POWER;
    else if (S=="SOLENOID")
        P=SOLENOID;
    else if (S=="BEAM")
        P=BEAM;
    else if (S=="CURRENT")
		P=CURRENT;
    else if (S=="DRIFT")
        P=DRIFT;
    else if (S=="CELL")
        P=CELL;
    else if (S=="CELLS")
        P=CELLS;
    else if (S=="OPTIONS")
		P=OPTIONS;
	else if (S=="SAVE")
		P=DUMP;
    else if (S=="SPCHARGE")
		P=SPCHARGE;
    else if (S[1]=='!')
		P=COMMENT;
	return  P;
}
//---------------------------------------------------------------------------
TSpaceChargeType TBeamSolver::ParseSpchType(AnsiString &S)
{
	TSpaceChargeType T;;

	if (S=="COULOMB")
		T=SPCH_ELL;
	else if (S=="GWMETHOD")
		T=SPCH_GW;
	else
		T=SPCH_NO;

	return T;
}
//---------------------------------------------------------------------------
void TBeamSolver::GetDimensions(TCell& Cell)
{
    
    int Nbp=0,Nep=0;
    int Nar=0,Nab=0;
    int Mode=Cell.Mode;

    switch (Mode) {
        case 90:    
            Nbp=Nb12; 
            Nep=Ne12;
            Nar=Nar23; 
            Nab=Nab23; 
            break;
        case 120:   
            Nbp=Nb23; 
            Nep=Ne23;
            Nar=Nar23; 
            Nab=Nab23; 
            break;
        case 240:   
            Nbp=Nb43; 
            Nep=Ne43;
            Nar=Nar43; 
            Nab=Nab23; 
            break;
        default: 
            return;
    }

    double *Xo,*Yo,*Xi,*Yi;
    
    Xo=new double[Nep];
    Yo=new double[Nep];
    Xi=new double[Nbp];
    Yi=new double[Nbp];

    //Searching for a/lmb

  /*FILE *T;
    T=fopen("table.log","a");     */

    for (int i=0;i<Nbp;i++){
        for (int j=0;j<Nep;j++){
            switch (Mode) {
                case 90:    
                    Xo[j]=E12[Nbp-i-1][j]; 
                    Yo[j]=R12[Nbp-i-1][j]; 
                    break;
                case 120:   
                    Xo[j]=E23[Nbp-i-1][j]; 
                    Yo[j]=R23[Nbp-i-1][j]; 
                    break;
                case 240:   
                    Xo[j]=E43[Nbp-i-1][j]; 
                    Yo[j]=R43[Nbp-i-1][j]; 
                    break;
                default: 
                    return;
            }
        }
        TSpline Spline;
        Spline.SoftBoundaries=false;
        Spline.MakeLinearSpline(Xo,Yo,Nep);
        Yi[i]=Spline.Interpolate(Cell.ELP);
       //   Xi[i]=mode90?B12[i]:B23[i];
        switch (Mode) {
            case 90:    
                Xi[i]=B12[i];
                break;
            case 120:   
                Xi[i]=B23[i];
                break;
            case 240:   
                Xi[i]=B43[i];
                break;
            default: 
                return;
        }
    }

    TSpline rSpline;
    rSpline.SoftBoundaries=false;
    rSpline.MakeLinearSpline(Xi,Yi,Nbp);
    Cell.AkL=rSpline.Interpolate(Cell.betta);

    delete[] Xo;
    delete[] Yo;
    delete[] Xi;
    delete[] Yi;

    Xo=new double[Nar];
    Yo=new double[Nar];
    Xi=new double[Nab];
    Yi=new double[Nab];

    for (int i=0;i<Nab;i++){
        for (int j=0;j<Nar;j++){
            switch (Mode) {
                case 90:    
                    Xo[j]=AR[j]; 
                    Yo[j]=A12[i][j]; 
                    break;
                case 120:   
                    Xo[j]=AR[j]; 
                    Yo[j]=A23[i][j]; 
                    break;
                case 240:   
                    Xo[j]=AR43[j]; 
                    Yo[j]=A43[i][j]; 
                    break;
                default: 
                    return;
            }

            /*Xo[j]=AR[j];
            Yo[j]=mode90?A12[i][j]:A23[i][j]; */
        }
        TSpline Spline;
        Spline.SoftBoundaries=false;
        Spline.MakeLinearSpline(Xo,Yo,Nar);
        Yi[i]=Spline.Interpolate(Cell.AkL);
        //Xi[i]=AB[i];
        switch (Mode) {
            case 90:    
                Xi[i]=AB[i];
                break;
            case 120:   
                Xi[i]=AB[i];
                break;
            case 240:   
                Xi[i]=AB[i];
                break;
            default: 
                return;
        }
    }

    TSpline aSpline;
    aSpline.SoftBoundaries=false;
    aSpline.MakeLinearSpline(Xi,Yi,Nab);
    Cell.AL32=1e-4*aSpline.Interpolate(Cell.betta);

    delete[] Xo;
    delete[] Yo;
    delete[] Xi;
    delete[] Yi;

  /*    fprintf(T,"%f %f %f %f\n",Cell.betta,Cell.ELP,Cell.AkL,Cell.AL32);
    fclose(T);  */
	//ShowError(E12[0][1]);

    
  /*    for (int i=0;i<Nbt;i++){
        akl[i]=solve(ELP(akl),ELP=E0,bf[i]);
    }
    akl(bf);
    y=interp(akl(bf),bf);    */


}
//---------------------------------------------------------------------------
TInputLine *TBeamSolver::ParseFile(int& N)
{
	const char *FileName=InputFile.c_str();
	AnsiString S,L,M;

	if (!CheckFile(InputFile)){
		S="ERROR: The input file "+InputFile+" was not found";
		ShowError(S);
		return NULL;
	}

	TInputLine *Lines;
	std::ifstream fs(FileName);
	TInputParameter P;
	int i=-1,j=0;

    FILE *logFile;
    while (!fs.eof()){
		S=GetWord(fs);   //Hid common actions inside the function
		if (S=="")
			continue;
		if(IsKeyWord(S) || S[1]=='!'){
			N++;
		}
/*        logFile=fopen("BeamSolver.log","a");
        fprintf(logFile,"ParseFile: N=%i, S=%s\n",N,S);
        fclose(logFile); */
    }

    fs.clear();
    fs.seekg(std::ios::beg);

    Lines=new TInputLine[N];

	while (!fs.eof()){
		L=GetLine(fs);   //Now reads line by line
		S=ReadWord(L,1);  //Gets the first word in the line (should be a key word)

		   /*	fs>>s;
			S=AnsiString(s);    */
/*            logFile=fopen("BeamSolver.log","a");
			fprintf(logFile,"ParseFile: s=%s, S=%s\n",s,S);
			fclose(logFile); */
		if (S=="END")
			break;
		else if (S=="") //empty line
			continue;
		else if(IsKeyWord(S) || S[1]=='!'){ //Key word or comment detected. Start parsing the line
			i++;
			P=Parse(S);
/*                logFile=fopen("BeamSolver.log","a");
				fprintf(logFile,"ParseFile: P=%s\n",P);
				fclose(logFile); */
/*				if(S=="COMMENT"){
					logFile=fopen("BeamSolver.log","a");
					fprintf(logFile,"ParseFile: Comment Line\n");
					fclose(logFile);
				}                  */
			Lines[i].P=P;

			if (P==COMMENT)       //comment length is not limited
				Lines[i].S[0]=L;
			else{
				Lines[i].N=NumWords(L)-1; //Parse number of words in the line
				if (Lines[i].N>MaxParameters){
					M="WARNING: Too many parameters in Line "+S+"! The excessive parameters will be ignored";
					Lines[i].N=MaxParameters;
					ShowError(M);
				}

				for (j=0;j<Lines[i].N;j++)
					Lines[i].S[j]=ReadWord(L,j+2);
			}
		}
	}

	fs.close();
    return Lines;
}
//---------------------------------------------------------------------------
AnsiString TBeamSolver::AddLines(TInputLine *Lines,int N1,int N2)
{
	AnsiString S="";

	for (int i=N1; i <= N2; i++) {
    	S+=" \t"+Lines->S[i];
	}

	return S;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParsePID(TInputLine *Line, AnsiString &F)
{
	AnsiString S;

	if (Line->N == 3){
		return ERR_BEAM;
	} else {
		AnsiString FileName=Line->S[1];
		if (CheckFile(FileName)) {
			BeamPar.RFile=FileName;
			F+=AddLines(Line,0,1);
			BeamPar.ZFile=FileName;
			BeamPar.ZBeamType=NORM_1D;

			if (Line->N > 3) {
				BeamPar.ZNorm.mean=DegreeToRad(Line->S[2].ToDouble());
				BeamPar.ZNorm.limit=DegreeToRad(Line->S[3].ToDouble());
				F+=AddLines(Line,2,3);

				if (Line->N > 4) {
					BeamPar.ZNorm.sigma=DegreeToRad(Line->S[4].ToDouble());
					F+=" \t"+Line->S[4];
				} else {
					BeamPar.ZNorm.sigma=100*BeamPar.ZNorm.limit;
				}
			} else {
				BeamPar.ZNorm.mean=pi;
				BeamPar.ZNorm.limit=pi;
				BeamPar.ZNorm.sigma=100*pi;
			}
		} else {
			S="ERROR: The file "+FileName+" is missing!";
			ShowError(S);
			return ERR_BEAM;
		}
	}

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParsePIT(TInputLine *Line, AnsiString &F)
{
	AnsiString FileName=Line->S[1],S;

	if (CheckFile(FileName)) {
		BeamPar.ZBeamType=BeamPar.RBeamType;
		BeamPar.RFile=FileName;
		BeamPar.ZFile=FileName;

		F+=AddLines(Line,0,1);

		if (Line->N == 3){
			if (Line->S[2]=="COMPRESS") {
				BeamPar.ZCompress=true;
				F+=" COMPRESS";
			} else {
				S="ERROR: Wrong keyword "+Line->S[2]+" in BEAM line";
				ShowError(S);
				return ERR_BEAM;
			}
		}
	} else {
		S="ERROR: The file "+FileName+" is missing!";
		ShowError(S);
		return ERR_BEAM;
	}

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseFile2R(TInputLine *Line, AnsiString &F, int Nr)
{
	AnsiString FileName=Line->S[1],S;

	if (CheckFile(FileName)) {
		BeamPar.RFile=FileName;
		F+=AddLines(Line,0,1);
	} else {
		S="ERROR: The file "+FileName+" is missing!";
		ShowError(S);
		return ERR_BEAM;
	}

	if (Nr==2){
		FileName=Line->S[2];
		if (CheckFile(FileName)) {
			BeamPar.YFile=FileName;
			F+=" \t"+FileName;
			BeamPar.RBeamType=TWO_FILES_2D;
		} else {
			S="ERROR: The file "+FileName+" is missing!";
			ShowError(S);
			return ERR_BEAM;
		}
	}
	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseTwiss2D(TInputLine *Line, AnsiString &F, int Nr)
{
	AnsiString S;

	if (Nr != 3){
		S="ERROR: Wrong number of Twiss parameters in BEAM line!";
		ShowError(S);
		return ERR_BEAM;
	}else{
		BeamPar.XTwiss.alpha=Line->S[1].ToDouble();
		BeamPar.XTwiss.beta=Line->S[2].ToDouble();
		BeamPar.XTwiss.epsilon=Line->S[3].ToDouble();
		BeamPar.YTwiss=BeamPar.XTwiss;
		F+=AddLines(Line,0,3);
	}
	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseTwiss4D(TInputLine *Line, AnsiString &F, int Nr)
{
	AnsiString S;

	if (Nr != 6){
		S="ERROR: Wrong number of Twiss parameters in BEAM line!";
		ShowError(S);
		return ERR_BEAM;
	}
	else{
		BeamPar.XTwiss.alpha=Line->S[1].ToDouble();
		BeamPar.XTwiss.beta=Line->S[2].ToDouble();
		BeamPar.XTwiss.epsilon=Line->S[3].ToDouble();
		BeamPar.YTwiss.alpha=Line->S[4].ToDouble();
		BeamPar.YTwiss.beta=Line->S[5].ToDouble();
		BeamPar.YTwiss.epsilon=Line->S[6].ToDouble();
		F+=AddLines(Line,0,6);
	}

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseSPH(TInputLine *Line, AnsiString &F, int Nr)
{
	AnsiString S;

    if (Nr>3){
		S="ERROR: Too many Spherical parameters in BEAM line!";
		ShowError(S);
		return ERR_BEAM;
	} else{
		BeamPar.Sph.Rcath=Line->S[1].ToDouble()/100; //Rcath cm
		F+=AddLines(Line,0,1);
		if (Nr>1) {
			BeamPar.Sph.Rsph=Line->S[2].ToDouble()/100;  //Rsph cm
			F+=" \t"+Line->S[1];
			if (Nr>2){
				BeamPar.Sph.kT=Line->S[3].ToDouble(); //kT
				F+=" \t"+Line->S[1];
			} else
				BeamPar.Sph.kT=0;
		} else {
			BeamPar.Sph.Rsph=0;
			BeamPar.Sph.kT=0;
		}
	}

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseELL(TInputLine *Line, AnsiString &F, int Nr)
{
	AnsiString S;

	if (Nr>4){
		S="ERROR: Too many Elliptical parameters in BEAM line!";
		ShowError(S);
		return ERR_BEAM;
	}else{
		BeamPar.Ell.ax=Line->S[1].ToDouble()/100; //x cm
		F+=AddLines(Line,0,1);
		if (Nr>1) {
			BeamPar.Ell.by=Line->S[2].ToDouble()/100; //y cm
			F+=" \t"+Line->S[2];
			if (Nr>2){
				BeamPar.Ell.phi=DegreeToRad(Line->S[3].ToDouble()); //phi
				F+=" \t"+Line->S[3];
				if (Nr>3){
					BeamPar.Ell.h=Line->S[4].ToDouble(); //h
					F+=" \t"+Line->S[4];
				} else
					BeamPar.Ell.h=1;
			} else {
				BeamPar.Ell.phi=0;
				BeamPar.Ell.h=1;
			}
		} else {
			BeamPar.Ell.by=BeamPar.Ell.ax; //y
			BeamPar.Ell.phi=0;
		 	BeamPar.Ell.h=1;
		}
	}
	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseFile1Z(TInputLine *Line, AnsiString &F, int Nz,int Zpos)
{
	AnsiString S;

	if (Nz != 3 && Nz != 4){
		S="ERROR: Wrong number of Import File (Z) or Phase Distribution parameters in BEAM line!";
		ShowError(S);
		return ERR_BEAM;
	}

	AnsiString FileName=Line->S[Zpos+1];
	if (CheckFile(FileName)) {
		BeamPar.ZFile=FileName;
		F+=AddLines(Line,Zpos,Zpos+1);
	} else {
		S="ERROR: The file "+FileName+" is missing!";
		ShowError(S);
		return ERR_BEAM;
	}

	BeamPar.ZNorm.mean=DegreeToRad(Line->S[Zpos+2].ToDouble());
	BeamPar.ZNorm.limit=DegreeToRad(Line->S[Zpos+3].ToDouble());
	F+=AddLines(Line,Zpos+2,Zpos+3);

	if (Nz == 3) {
		BeamPar.ZNorm.sigma=100*BeamPar.ZNorm.limit;
	} else  if (Nz == 4) {
		BeamPar.ZNorm.sigma=DegreeToRad(Line->S[Zpos+4].ToDouble());
		F+=Line->S[Zpos+4];
	}

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseFile2Z(TInputLine *Line, AnsiString &F, int Nz,int Zpos)
{
	AnsiString S;

	if (Nz != 1){
		S="ERROR: Too many Import File (Z) parameters in BEAM line!";
		ShowError(S);
		return ERR_BEAM;
	}

	AnsiString FileName=Line->S[Zpos+1];
	if (CheckFile(FileName)) {
		BeamPar.ZFile=FileName;
		F+=AddLines(Line,Zpos,Zpos+1);
	} else {
		S="ERROR: The file "+FileName+" is missing!";
		ShowError(S);
		return ERR_BEAM;
	}

	return ERR_NO;
}
 //---------------------------------------------------------------------------
TError TBeamSolver::ParseNorm(TInputLine *Line, AnsiString &F, int Nz,int Zpos)
{
	AnsiString S;

	if (Nz != 4 && Nz != 6){
		S="Wrong number of Longitudinal Distribution parameters in BEAM line!";
		ShowError(S);
		return ERR_BEAM;
	}else{
		if (Nz == 4) {
			BeamPar.WNorm.mean=Line->S[Zpos+1].ToDouble();
			BeamPar.WNorm.limit=Line->S[Zpos+2].ToDouble();
			BeamPar.WNorm.sigma=100*BeamPar.WNorm.limit;
			BeamPar.ZNorm.mean=DegreeToRad(Line->S[Zpos+3].ToDouble());
			BeamPar.ZNorm.limit=DegreeToRad(Line->S[Zpos+4].ToDouble());
			BeamPar.ZNorm.sigma=100*BeamPar.ZNorm.limit;
			F+=AddLines(Line,Zpos,Zpos+4);
		} else  if (Nz == 6) {
			BeamPar.WNorm.mean=Line->S[Zpos+1].ToDouble();
			BeamPar.WNorm.limit=Line->S[Zpos+2].ToDouble();
			BeamPar.WNorm.sigma=Line->S[Zpos+3].ToDouble();
			BeamPar.ZNorm.mean=DegreeToRad(Line->S[Zpos+4].ToDouble());
			BeamPar.ZNorm.limit=DegreeToRad(Line->S[Zpos+5].ToDouble());
			BeamPar.ZNorm.sigma=DegreeToRad(Line->S[Zpos+6].ToDouble());
			F+=AddLines(Line,Zpos,Zpos+6);
		}
	}

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseOptions(TInputLine *Line)
{
	TError Error=ERR_NO;
	AnsiString F="OPTIONS ";

	for (int j=0;j<Line->N;j++){
		if (Line->S[j]=="REVERSE")
			StructPar.Reverse=true;

		if (Line->S[j]=="MAGNETIZED")
			BeamPar.Magnetized=true;

		F=F+"\t"+Line->S[j];
	}
	ParsedStrings->Add(F);

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseSpaceCharge(TInputLine *Line)
{
	AnsiString F="SPCHARGE ",S;
	BeamPar.SpaceCharge.Type=SPCH_NO;
	BeamPar.SpaceCharge.NSlices=1;

	if (Line->N==0){
		BeamPar.SpaceCharge.Type=SPCH_ELL;
		F=F+"\t"+"COULOMB";
	}else if (Line->N<3) {
		BeamPar.SpaceCharge.Type=ParseSpchType(Line->S[0]);
		F=F+"\t"+Line->S[0];
		switch (BeamPar.SpaceCharge.Type) {
			case SPCH_GW: {
				if (Line->N==2){
					BeamPar.SpaceCharge.NSlices=Line->S[1].ToInt();
					F=F+"\t"+Line->S[1];
				}
				break;
			}
			case SPCH_ELL: {}
			case SPCH_NO: { break;}
			default: {return ERR_SPCHARGE;};
		}

	} else {
		S="ERROR: Too many parametes in SPCHARGE line!";
		ShowError(S);
		return ERR_SPCHARGE;
	}

	ParsedStrings->Add(F);
	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseSolenoid(TInputLine *Line)
{
	AnsiString F="SOLENOID",SolenoidFile,S;

	if (Line->N==3){
		StructPar.SolenoidPar.ImportType=ANALYTIC_0D;
		StructPar.SolenoidPar.BField=Line->S[0].ToDouble()/10000; //[Gs]
		StructPar.SolenoidPar.Length=Line->S[1].ToDouble()/100; //[cm]
		StructPar.SolenoidPar.StartPos=Line->S[2].ToDouble()/100; //[cm]

		F+=AddLines(Line,0,2);
		ParsedStrings->Add(F);
	}else if (Line->N==1) {
		SolenoidFile=Line->S[0];
		F+="\t"+SolenoidFile;
		if (CheckFile(SolenoidFile)){
			StructPar.SolenoidPar.ImportType=IMPORT_1D;
			StructPar.SolenoidPar.File=SolenoidFile;
			ParsedStrings->Add(F);
		}else{
			S="ERROR: The file "+SolenoidFile+" is missing!";
			ShowError(S);
			return ERR_SOLENOID;
		}
	}else
		return ERR_SOLENOID;

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseBeam(TInputLine *Line)
{
	TError Error=ERR_NO;
	AnsiString F="BEAM",S;

	if (Line->N < 1)
		return ERR_BEAM;

	AnsiString KeyWord=Line->S[0];
	BeamPar.RBeamType=ParseDistribution(KeyWord);
	BeamPar.ZCompress=false;

	if (BeamPar.RBeamType==NOBEAM) {
		S="ERROR: Wrong KEYWORD in BEAM line";
		ShowError(S);
		return ERR_BEAM;
	 }

	 if (IsFullFileKeyWord(BeamPar.RBeamType)) {
		if (Line->N < 2 || Line->N >5)
			return ERR_BEAM;

			switch (BeamPar.RBeamType) {
				case CST_PID: {
					Error=ParsePID(Line,F);
					break;
				}
				case CST_PIT: {
					Error=ParsePIT(Line,F);
					break;
				}
				default: {
					S="ERROR: Unexpected Input File Type";
					ShowError(S);
					return ERR_BEAM;
				}
			}
	 } else if (IsTransverseKeyWord(BeamPar.RBeamType)) {
		int Zpos=0;
		for (int j=1; j < Line->N; j++) {
			if (IsLongitudinalKeyWord(ParseDistribution(Line->S[j]))) {
				Zpos=j;
				break;
			}
		}
		if (Zpos==0) {
			S="Longitudinal Distribution Type is not defined in BEAM line";
			ShowError(S);
			return ERR_BEAM;
		}
		int Nr=Zpos-1; // Number of R-parameters
		int Nz=Line->N-Zpos-1; //Number of Z-parameters

		if (Nr==0 || Nz==0) {
			S="Too few parametes in BEAM line!";
			ShowError(S);
			return ERR_BEAM;
		}

		switch (BeamPar.RBeamType) {
			case FILE_4D: {
				if (Nr!=1){
					S="Too many Import File (R) parameters in BEAM line!";
					ShowError(S);
					return ERR_BEAM;
				}
			}
			case FILE_2D: {
				if (Nr>2){
					S="Too many Import File (R) parameters in BEAM line!";
					ShowError(S);
					return ERR_BEAM;
				}
				Error=ParseFile2R(Line,F,Nr);
				break;
			}
			case TWISS_2D: {
				Error=ParseTwiss2D(Line,F,Nr);
				break;
			}
			case TWISS_4D: {
				Error=ParseTwiss4D(Line,F,Nr);
				break;
			}
			case SPH_2D: {
				Error=ParseSPH(Line,F,Nr);
				break;
			}
			case ELL_2D: {
				Error=ParseELL(Line,F,Nr);
				break;
			}
			default: {
				S="Unexpected BEAM Transversal Distribution Type";
				ShowError(S);
				return ERR_BEAM;
			}
		}
		KeyWord=Line->S[Zpos];
		BeamPar.ZBeamType=ParseDistribution(KeyWord);

		if (IsLongitudinalKeyWord(BeamPar.ZBeamType)) {
			switch (BeamPar.ZBeamType) {
				case FILE_1D: {
					Error=ParseFile1Z(Line,F,Nz,Zpos);
					break;
				}
				case FILE_2D: {
					Error=ParseFile2Z(Line,F,Nz,Zpos);
					break;
				}
				case NORM_2D: {
					Error=ParseNorm(Line,F,Nz,Zpos);
					break;
				}
				default: {
					S="ERROR:Unexpected BEAM Longitudinal Distribution Type";
					ShowError(S);
					return ERR_BEAM;
				}
			}
		} else{
			S="ERROR: Unexpected BEAM Longitudinal Distribution Type";
			ShowError(S);
			return ERR_BEAM;
		}
	 }  else  {
		S="ERROR: Wrong Format of BEAM line";
		ShowError(S);
		return ERR_BEAM;
	 }
	 ParsedStrings->Add(F);

	 return Error;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseCurrent(TInputLine *Line)
{
	AnsiString F="CURRENT",S;
	if (Line->N<1 || Line->N>2){
		return ERR_CURRENT;
	}  else {
		BeamPar.Current=Line->S[0].ToDouble();
		F+="\t"+Line->S[0];
		if (!IsFileKeyWord(BeamPar.RBeamType) && !IsFileKeyWord(BeamPar.ZBeamType)) {
			if (Line->N!=2){
				S="ERROR: Number of particles is not defined!";
				ShowError(S);
				return ERR_CURRENT;
			} else {
				BeamPar.NParticles=Line->S[1].ToInt();
				F+="\t"+Line->S[1];
			}
		} else {
			int Nr=0, Ny=0, Nz=0, Np=0;

			if (IsFullFileKeyWord(BeamPar.RBeamType)){
				switch (BeamPar.RBeamType) {
					case CST_PID:{
						Nr=NumPointsInFile(BeamPar.RFile,PID_LENGTH);
						break;
					}
					case CST_PIT:{
						Nr=NumPointsInFile(BeamPar.RFile,PIT_LENGTH);
						break;
					}
					default:  {
						S="ERROR: Unexpected BEAM File Format!";
						ShowError(S);
						return ERR_IMPORT;
					}
				}

				Nz=Nr;
			} else {
				switch (BeamPar.RBeamType) {
					case FILE_2D: {
						Nr=NumPointsInFile(BeamPar.RFile,2);
						break;
					}
					case TWO_FILES_2D: {
						Nr=NumPointsInFile(BeamPar.RFile,2);
						Ny=NumPointsInFile(BeamPar.YFile,2);
						if (Nr!=Ny) {
							S="ERROR: The numbers of imported particles from two Transverse Beam Files don't match!";
							ShowError(S);
							return ERR_IMPORT;
						}
						break;
					}
					case FILE_4D: {
						Nr=NumPointsInFile(BeamPar.RFile,4);
						break;
					}
					default:  {
						Nr=-1;
						break;
					}
				}

				switch (BeamPar.ZBeamType) {
					case FILE_1D: {
						Nz=NumPointsInFile(BeamPar.ZFile,1);
						break;
					}
					case FILE_2D: {
						Nz=NumPointsInFile(BeamPar.ZFile,2);
						break;
					}
					default:  {
						Nz=Nr;
						break;
					}
				}

				if (Nr==-1)
					Nr=Nz;


			}
			//check Np mismatch
			if (IsFileKeyWord(BeamPar.RBeamType) && IsFileKeyWord(BeamPar.ZBeamType)){
				if (Nr!=Nz) {
					S="ERROR: The number of imported particles from Longintudinal Beam File doesn't match with the number of particles imported from Transversal Beam File!";
					ShowError(S);
					return ERR_IMPORT;
				}
			}

			//check Np overrride
			if (Line->N==2) {
				Np=Line->S[1].ToInt();

				if (Np>Nr) {
					S="WARNING: The number of defined particles exceeds the number of imported particles, and will be ignored!";
					ShowError(S);
				}  else if (Np<Nr) {
					S="WARNING: The number of defined particles is less than the number of imported particles! Only the first "+Line->S[1]+" particles will be simulated";
					ShowError(S);
					Nr=Np;
				}
				F+=" "+Line->S[1];
			}
			BeamPar.NParticles=Nr;
		}
	}

	ParsedStrings->Add(F);

	return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::ParseLines(TInputLine *Lines,int N,bool OnlyParameters)
{
	int Ni=0, Nsec=0;
	double dF=0;
	double F_last=0, P_last=0;

	TError Error=ERR_NO;

	bool BeamDefined=false;
	bool CurrentDefined=false;
	bool CellDefined=false;
	bool PowerDefined=false;

	bool NewCell=true;
	AnsiString F,S,s;
    ParsedStrings->Clear();

   // FILE *logFile;
	for (int k=0;k<N;k++){
	 /*   logFile=fopen("BeamSolver.log","a");
        fprintf(logFile,"ParseLines: Line %i \n",k);
		fclose(logFile);     */
		switch (Lines[k].P) {
			case UNDEFINED: {
				throw std::logic_error("Unhandled TInputParameter UNDEFINED in TBeamSolver::ParseLines");
			}
			case OPTIONS:{
				Error=ParseOptions(&Lines[k]);
								break;
			}
			case SPCHARGE:{
				Error=ParseSpaceCharge(&Lines[k]);
				break;
			}
			case SOLENOID:{
				Error=ParseSolenoid(&Lines[k]);
				break;
			}
			case BEAM:{
				Error=ParseBeam(&Lines[k]);
				BeamDefined=Error==ERR_NO;
				break;
			}
			case CURRENT:{
				Error=ParseCurrent(&Lines[k]);
				CurrentDefined=Error==ERR_NO;
				break;
			}
			case CELL:{
				if(OnlyParameters)
                    break;
				if (Lines[k].N==3 || Lines[k].N==5){
					StructPar.Cells[Ni].Mode=Lines[k].S[0].ToDouble();
					StructPar.Cells[Ni].betta=Lines[k].S[1].ToDouble();
					StructPar.Cells[Ni].ELP=Lines[k].S[2].ToDouble();
					StructPar.Cells[Ni].Mesh=Nmesh;

					if (Lines[k].N==3){
						GetDimensions(StructPar.Cells[Ni]);
					} else if (Lines[k].N==5){
						StructPar.Cells[Ni].AL32=Lines[k].S[3].ToDouble();
						StructPar.Cells[Ni].AkL=Lines[k].S[4].ToDouble();
					}
				} else{
                    return ERR_CELL;
                }

                F="CELL "+Lines[k].S[0]+"\t"+s.FormatFloat("#0.000",StructPar.Cells[Ni].betta)+"\t"+s.FormatFloat("#0.000",StructPar.Cells[Ni].ELP)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[Ni].AL32)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[Ni].AkL);
                ParsedStrings->Add(F);

				StructPar.Cells[Ni].F0=F_last*1e6;
				StructPar.Cells[Ni].P0=P_last*1e6;
				StructPar.Cells[Ni].dF=arc(dF);
			   //	Cells[Ni].Drift=false;
				StructPar.Cells[Ni].First=NewCell;
				StructPar.Sections[Nsec-1].NCells++;
				if (NewCell && !PowerDefined) {
					S="ERROR: The RF power source must be defined before each RF section. Put POWER line in correct format into the input file before the end of each RF section. Note that DRIFT element terminates the defined RF power!";
					ShowError(S);
					Error=ERR_FORMAT;
				}
				NewCell=false;
				dF=0;

				Ni++;
			 	if (StructPar.ElementsLimit>-1 &&Ni>=StructPar.ElementsLimit)
					OnlyParameters=true;

				CellDefined=true;		
                break;
            }

            case CELLS:{
                if(OnlyParameters)
                    break;
				if (Lines[k].N==4 || Lines[k].N==6){
					for (int j=0;j<Lines[k].S[0].ToInt();j++){
						StructPar.Cells[Ni].Mode=Lines[k].S[1].ToDouble();
						StructPar.Cells[Ni].betta=Lines[k].S[2].ToDouble();
						StructPar.Cells[Ni].ELP=Lines[k].S[3].ToDouble();
						StructPar.Cells[Ni].Mesh=Nmesh;
						if (Lines[k].N==4)
							GetDimensions(StructPar.Cells[Ni]);
						else if (Lines[k].N==6){
							StructPar.Cells[Ni].AL32=Lines[k].S[4].ToDouble();
							StructPar.Cells[Ni].AkL=Lines[k].S[5].ToDouble();
						}
						StructPar.Cells[Ni].F0=F_last*1e6;
						StructPar.Cells[Ni].P0=P_last*1e6;
						StructPar.Cells[Ni].dF=arc(dF);
					 //   Cells[Ni].Drift=false;
						StructPar.Cells[Ni].First=NewCell;
                        StructPar.Sections[Nsec-1].NCells++;
						if (NewCell && !PowerDefined) {
							S="ERROR: The RF power source must be defined before each RF section. Put POWER line in correct format into the input file before the end of each RF section. Note that DRIFT element terminates the defined RF power!";
							ShowError(S);
							Error=ERR_FORMAT;
						}
						NewCell=false;
						dF=0;

                        Ni++;
						if (StructPar.ElementsLimit>-1 &&Ni>=StructPar.ElementsLimit){
							OnlyParameters=true;
							break;
						}
                    }
				} else{
					return ERR_CELLS;
				}
				if (Ni>0){
					F="CELLS "+Lines[k].S[0]+"\t"+Lines[k].S[1]+"\t"+s.FormatFloat("#0.000",StructPar.Cells[Ni-1].betta)+"\t"+s.FormatFloat("#0.000",StructPar.Cells[Ni-1].ELP)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[Ni-1].AL32)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[Ni-1].AkL);
					ParsedStrings->Add(F);
				}

				CellDefined=true;
                break;
            }
            case DRIFT:{
				if(OnlyParameters)
					break;
				if (Lines[k].N<2 || Lines[k].N>3){
					return ERR_DRIFT;
				}
				StructPar.Cells[Ni].Drift=true;
				StructPar.Cells[Ni].betta=Lines[k].S[0].ToDouble()/100;//D, cm
				StructPar.Cells[Ni].AkL=Lines[k].S[1].ToDouble()/100;//Ra, cm
				if (Lines[k].N==3){
					double m=Lines[k].S[2].ToDouble();
					if (m>1)
						StructPar.Cells[Ni].Mesh=m;
					else{
						S="WARNING: Number of mesh points must be more than 1";
						ShowError(S);
						StructPar.Cells[Ni].Mesh=Nmesh;
                    }
				}
				else
					StructPar.Cells[Ni].Mesh=Nmesh;

				StructPar.Cells[Ni].ELP=0;
				StructPar.Cells[Ni].AL32=0;
				StructPar.Cells[Ni].First=true;
				StructPar.Cells[Ni].F0=c;
				StructPar.Cells[Ni].dF=arc(dF);
				dF=0;
				NewCell=true;
				PowerDefined=false;

				F="DRIFT "+Lines[k].S[0]+" \t"+Lines[k].S[1];
				ParsedStrings->Add(F);

				Ni++;
				if (StructPar.ElementsLimit>-1 && Ni>=StructPar.ElementsLimit)
					OnlyParameters=true;
				break;
			}
			case POWER:{
				if (Lines[k].N>=2 && Lines[k].N<=3){
					Nsec++;

					P_last=Lines[k].S[0].ToDouble();
					F_last=Lines[k].S[1].ToDouble();
					if(Lines[k].N==3)
						dF=Lines[k].S[2].ToDouble();

					if (Nsec>StructPar.NSections) {
						S="ERROR: Inconsistent number of sections!";
						ShowError(S);
						return ERR_COUPLER;
					} else {
						StructPar.Sections[Nsec-1].Power=P_last;
						StructPar.Sections[Nsec-1].Frequency=F_last;
						//StructPar.Sections[Nsec-1].Wavelength=1e-6*c/F_last;
						StructPar.Sections[Nsec-1].NCells=0;
					}
					
					NewCell=true;
				} else {
					return ERR_COUPLER;
				}

				F="POWER "+Lines[k].S[0]+"\t"+Lines[k].S[1]+"\t"+s.FormatFloat("#0.00",dF);
				ParsedStrings->Add(F);

				PowerDefined=true;
				break;
			}
			case DUMP:{
				if (Lines[k].N>=1 && Lines[k].N<=9){
					StructPar.Cells[Ni].Dump=true;
					StructPar.Cells[Ni].DumpParameters.File=Lines[k].S[0].c_str();
					StructPar.Cells[Ni].DumpParameters.LiveOnly=true;
					StructPar.Cells[Ni].DumpParameters.Phase=false;
					StructPar.Cells[Ni].DumpParameters.Energy=false;
					StructPar.Cells[Ni].DumpParameters.Radius=false;
					StructPar.Cells[Ni].DumpParameters.Azimuth=false;
					StructPar.Cells[Ni].DumpParameters.Vx=false;
					bool DefaultSet=true;
					int Nkey=1; // the word from which the flags are checked

					F="SAVE "+Lines[k].S[0];
					if (Lines[k].N>=2 && IsNumber(Lines[k].S[1])) {
						StructPar.Cells[Ni].DumpParameters.N1=Lines[k].S[1].ToDouble();
						F=F+" "+Lines[k].S[1];
						Nkey=2;
						if (Lines[k].N>=3 && IsNumber(Lines[k].S[2])){
							StructPar.Cells[Ni].DumpParameters.N2=Lines[k].S[2].ToDouble();
							F=F+" "+Lines[k].S[2];
							Nkey=3;
						}
						else
							StructPar.Cells[Ni].DumpParameters.N2=0;
					}  else {
						StructPar.Cells[Ni].DumpParameters.N1=0;
						StructPar.Cells[Ni].DumpParameters.N2=0;
					}
					if (Lines[k].N>=2 && Lines[k].N<=9) {
						for (int j=Nkey;j<Lines[k].N;j++){
							if (Lines[k].S[j]=="LOST") {
								StructPar.Cells[Ni].DumpParameters.LiveOnly=false;
								F=F+" LOST";
							}
							else if (Lines[k].S[j]=="PHASE") {
								StructPar.Cells[Ni].DumpParameters.Phase=true;
								F=F+" PHASE";
								DefaultSet=false;
							}
							else if (Lines[k].S[j]=="ENERGY") {
								StructPar.Cells[Ni].DumpParameters.Energy=true;
								F=F+" ENERGY";
								DefaultSet=false;
							}
							else if (Lines[k].S[j]=="RADIUS") {
								StructPar.Cells[Ni].DumpParameters.Radius=true;
								F=F+" RADIUS";
								DefaultSet=false;
							}
							else if (Lines[k].S[j]=="AZIMUTH") {
								StructPar.Cells[Ni].DumpParameters.Azimuth=true;
								F=F+" AZIMUTH";
								DefaultSet=false;
							}
							else if (Lines[k].S[j]=="VX") {
								StructPar.Cells[Ni].DumpParameters.Vx=true;
								F=F+" VX";
								DefaultSet=false;
							} else {
								S="WARNING: The keyword "+Lines[k].S[j]+" in SAVE line is not recognized and will be ignored";
								ShowError(S);
							}
						}
					}
					if (DefaultSet) {
						StructPar.Cells[Ni].DumpParameters.Phase=true;
						StructPar.Cells[Ni].DumpParameters.Energy=true;
						StructPar.Cells[Ni].DumpParameters.Radius=true;
						StructPar.Cells[Ni].DumpParameters.Azimuth=true;
						StructPar.Cells[Ni].DumpParameters.Vx=true;
					}

					//check the numbers
					if (StructPar.Cells[Ni].DumpParameters.N1<0 || StructPar.Cells[Ni].DumpParameters.N2<0) {
						S="WARNING: The particle numbers in SAVE line can not be negative. The region will be ignored.";
						ShowError(S);
						StructPar.Cells[Ni].DumpParameters.N1=0;
						StructPar.Cells[Ni].DumpParameters.N2=0;
					} else if (StructPar.Cells[Ni].DumpParameters.N2!=0 && StructPar.Cells[Ni].DumpParameters.N1>StructPar.Cells[Ni].DumpParameters.N2) {
						int temp=StructPar.Cells[Ni].DumpParameters.N2; //switch the numbers
						StructPar.Cells[Ni].DumpParameters.N2=StructPar.Cells[Ni].DumpParameters.N1;
						StructPar.Cells[Ni].DumpParameters.N1=temp;
					}

					ParsedStrings->Add(F);
				} else {    // else skip the line
					S="WARNING: The format of SAVE line is wrong and will be ignored.";
					ShowError(S);
				}
				break;
			}
			case COMMENT:{
				ParsedStrings->Add(Lines[k].S[0]);
				break;
			}

		}

		if (Error!=ERR_NO)
			return Error;
	}

	if (!BeamDefined) {
		S="ERROR: The beam particles distribution not defined. Put BEAM line in correct format into the input file";
		ShowError(S);
		Error=ERR_FORMAT;
	}
	if (!CurrentDefined) {
		S="ERROR: The beam current is not defined. Put CURRENT line in correct format into the input file";
		ShowError(S);
		Error=ERR_FORMAT;
	}
	if (Ni<1) {
		S="ERROR: The accelerating structure is not defined. Put at least one element (CELL, DRIFT) line in correct format into the input file";
		ShowError(S);
		Error=ERR_FORMAT;
	}
   /*	if (CellDefined && !PowerDefined) {
		ShowError("ERROR: The RF power source must be defined before each RF section. Put POWER line in correct format into the input file before the end of each RF section");
		Error=ERR_FORMAT;
	}       */

	return Error;
}
//---------------------------------------------------------------------------
TError TBeamSolver::LoadData(int Nlim)
{
    const char *FileName=InputFile.c_str();
    LoadIniConstants();
    InputStrings->Clear();
	StructPar.ElementsLimit=Nlim; //# of cells limit. Needed for optimizer. Don't remove

    DataReady=false;

    if (strncmp(FileName, "", 1) == 0) {
        return ERR_NOFILE;
    }
    if (!FileExists(FileName)) {
        return ERR_OPENFILE;
    }

	AnsiString S;
    TInputLine *Lines;
    int i=-1,j=0,N=0;
    TError Parsed;

    Lines=ParseFile(N);
    //InputStrings->LoadFromFile(InputFile);

	ResetStructure();

	for (int k=0;k<N;k++){
		if (Lines[k].P==CELL || Lines[k].P==DRIFT)
			StructPar.NElements++;
		else if (Lines[k].P==CELLS)
			StructPar.NElements+=Lines[k].S[0].ToInt();
		else if (Lines[k].P==POWER)
			StructPar.NSections++;
	}

	if (StructPar.ElementsLimit>-1 && StructPar.NElements>=StructPar.ElementsLimit){  //# of cells limit. Needed for optimizer
		StructPar.NElements=StructPar.ElementsLimit;
		S="The number of elements exceeds the user-defined limit. Check the hellweg.ini file";
		ShowError(S);
	}


	StructPar.Cells = new TCell[StructPar.NElements+1];  //+1 - end point
	for (int k=0;k<StructPar.NElements+1;k++){
		StructPar.Cells[k].Dump=false;
		StructPar.Cells[k].Drift=false;
		StructPar.Cells[k].First=false;
	}

	if (StructPar.NSections==0){
		StructPar.NSections==1; //default section!
		StructPar.Sections=new TSectionParameters [StructPar.NSections];
		//StructPar.Sections[0].Wavelength=1;
		StructPar.Sections[0].Frequency=300;
		StructPar.Sections[0].Power=0;
		StructPar.Sections[0].NCells=0;
	} else
		StructPar.Sections=new TSectionParameters [StructPar.NSections];

	Parsed=ParseLines(Lines,N);
    ParsedStrings->Add("END");
    InputStrings->AddStrings(ParsedStrings);
    
    ParsedStrings->SaveToFile("PARSED.TXT");

    delete[] Lines;
    DataReady=true;
    return Parsed;
}
//---------------------------------------------------------------------------
TError TBeamSolver::MakeBuncher(TCell& iCell)
{
    const char *FileName=InputFile.c_str();
    InputStrings->Clear();
    //LoadIniConstants();

    DataReady=false;
    TError Error;

    if (strncmp(FileName, "", 1) == 0) {
        return ERR_NOFILE;
    } 
    if (!FileExists(FileName)) {
        return ERR_OPENFILE;
    }

	ResetStructure();

    AnsiString F,s;
    TInputLine *Lines;
    int i=-1,j=0,N=0;

    Lines=ParseFile(N);
    Error=ParseLines(Lines,N,true);

	//NOT CLEAR. MAY NEED TO UNCOMMENT AND REWRITE
   if (StructPar.Sections[0].Frequency*1e6!=iCell.F0 || StructPar.Sections[0].Power*1e6!=iCell.P0){
		StructPar.Sections[0].Frequency=iCell.F0*1e-6;
		StructPar.Sections[0].Power=iCell.P0*1e-6;
		F="POWER "+s.FormatFloat("#0.00",StructPar.Sections[0].Power)+"\t"+s.FormatFloat("#0.00",StructPar.Sections[0].Frequency);
        ParsedStrings->Add(F);
	}

    ParsedStrings->Add("");

    double k1=0,k2=0,k3=0,k4=0,k5=0;
	double Am=iCell.ELP*sqrt(StructPar.Sections[0].Power*1e6)/We0;
    k1=3.8e-3*(Power(10.8,Am)-1);
    k2=1.25*Am+2.25;
    k3=0.5*Am+0.15*sqrt(Am);
    k4=0.5*Am-0.15*sqrt(Am);
    k5=1/sqrt(1.25*sqrt(Am));

	double b=0,A=0,ksi=0,lmb=0,th=0;
	double W0=Beam[0]->GetAverageEnergy();
	double b0=MeVToVelocity(W0);

	lmb=1e-6*c/StructPar.Sections[0].Frequency;
    if (iCell.Mode==90)
        th=pi/2;
    else if (iCell.Mode==120)
        th=2*pi/3;

	StructPar.NElements=0;
	StructPar.NSections=1;

	TSectionParameters Sec;
	Sec=StructPar.Sections[0];
	delete [] StructPar.Sections;
	StructPar.Sections=new TSectionParameters [StructPar.NSections];
	StructPar.Sections[0]=Sec;
   //	Ncells=0;
    int iB=0;

    do {
        b=(2/pi)*(1-b0)*arctg(k1*Power(ksi,k2))+b0;
       //   b=(2/pi)*arctg(0.25*sqr(10*ksi*lmb)+0.713);
		iB=10000*b;
        ksi+=b*th/(2*pi);
		StructPar.NElements++;
    } while (iB<9990);
    //} while (ksi*lmb<1.25);

	StructPar.Cells=new TCell[StructPar.NElements];

    ksi=0;
	for (int i=0;i<StructPar.NElements;i++){
        ksi+=0.5*b*th/(2*pi);

        b=(2/pi)*(1-b0)*arctg(k1*Power(ksi,k2))+b0;
       //   b=(2/pi)*arctg(0.25*sqr(10*ksi*lmb)+0.713);

        A=k3-k4*cos(pi*ksi/k5);
        //A=3.0e6*sin(0.11*sqr(10*ksi*lmb)+0.64);
       /*
        if (ksi*lmb>0.3)
            A=3.00e6;     */

        if (ksi>k5)
            A=Am;

        ksi+=0.5*b*th/(2*pi);

		StructPar.Cells[i].Mode=iCell.Mode;
		StructPar.Cells[i].betta=(2/pi)*(1-b0)*arctg(k1*Power(ksi,k2))+b0;
        //Cells[i].betta=(2/pi)*arctg(0.25*sqr(10*ksi*lmb)+0.713);

		StructPar.Cells[i].ELP=A*We0/sqrt(1e6*StructPar.Sections[0].Power);
       //   Cells[i].ELP=A*lmb/sqrt(1e6*P0);

		GetDimensions(StructPar.Cells[i]);

		F="CELL "+s.FormatFloat("#0",iCell.Mode)+"\t"+s.FormatFloat("#0.000",StructPar.Cells[i].betta)+"\t"+s.FormatFloat("#0.000",StructPar.Cells[i].ELP)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[i].AL32)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[i].AkL);
		ParsedStrings->Add(F);

		StructPar.Cells[i].F0=StructPar.Sections[0].Frequency*1e6;
		StructPar.Cells[i].P0=StructPar.Sections[0].Power*1e6;
		StructPar.Cells[i].dF=0;
		StructPar.Cells[i].Drift=false;
		StructPar.Cells[i].First=false;
    }
    StructPar.Cells[0].First=true;

    ParsedStrings->Add("END");
    InputStrings->AddStrings(ParsedStrings);
    ParsedStrings->SaveToFile("PARSED.TXT");

    return Error;
}
//---------------------------------------------------------------------------
int TBeamSolver::ChangeCells(int N)
{
    TCell *iCells;
	iCells=new TCell[StructPar.NElements];

	for (int i=0;i<StructPar.NElements;i++)
		iCells[i]=StructPar.Cells[i];

	delete[] StructPar.Cells;

	int Nnew=StructPar.NElements<N?StructPar.NElements:N;
	int Nprev=StructPar.NElements;
	StructPar.NElements=N;

	StructPar.Cells=new TCell[StructPar.NElements];
    
    for (int i=0;i<Nnew;i++)
        StructPar.Cells[i]=iCells[i];

    delete[] iCells;
    
    return Nprev;
}
//---------------------------------------------------------------------------
void TBeamSolver::AppendCells(TCell& iCell,int N)
{
	int Nprev=ChangeCells(StructPar.NElements+N);
    int i=InputStrings->Count-1;
    InputStrings->Delete(i);

    i=Nprev;
	StructPar.Cells[i]=iCell;
	GetDimensions(StructPar.Cells[i]);

	for (int j=Nprev;j<StructPar.NElements;j++)
		StructPar.Cells[j]=StructPar.Cells[i];

    AnsiString F,F1,s;
	F1=F=s.FormatFloat("#0",iCell.Mode)+"\t"+s.FormatFloat("#0.000",StructPar.Cells[i].betta)+"\t"+s.FormatFloat("#0.000",StructPar.Cells[i].ELP)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[i].AL32)+"\t"+s.FormatFloat("#0.000000",StructPar.Cells[i].AkL);
	if (N==1)
		F="CELL "+F1;
    else
        F="CELLS "+s.FormatFloat("#0",N)+F1;

    InputStrings->Add(F);
    InputStrings->Add("END");

}
//---------------------------------------------------------------------------
void TBeamSolver::AddCells(int N)
{
	TCell pCell=StructPar.Cells[StructPar.NElements-1];
	AppendCells(pCell,N);
}
//---------------------------------------------------------------------------
TCell TBeamSolver::GetCell(int j)
{
    if (j<0)
        j=0;
	if (j>=StructPar.NElements)
		j=StructPar.NElements-1;

	return StructPar.Cells[j];
}
//---------------------------------------------------------------------------
TCell TBeamSolver::LastCell()
{
    return GetCell(StructPar.NElements-1);
}
//---------------------------------------------------------------------------
void TBeamSolver::ChangeInputCurrent(double Ib)
{
    BeamPar.Current=Ib;
}
//---------------------------------------------------------------------------
double *TBeamSolver::SmoothInterpolation(double *x,double *X,double *Y,int Nbase,int Nint,double p0,double *W)
{
    TSpline *Spline;
    double *y;
    //y=new double[Nint];

    Spline=new TSpline;
    Spline->MakeSmoothSpline(X,Y,Nbase,p0,W);
    y=Spline->Interpolate(x,Nint);

    delete Spline;

    return y;
}
//---------------------------------------------------------------------------
double *TBeamSolver::SplineInterpolation(double *x,double *X,double *Y,int Nbase,int Nint)
{
    TSpline *Spline;
    double *y;
    y=new double[Nint];

    Spline=new TSpline;
    Spline->MakeCubicSpline(X,Y,Nbase);
    y=Spline->Interpolate(x,Nint);

    delete Spline;

    return y;
}
//---------------------------------------------------------------------------
double *TBeamSolver::LinearInterpolation(double *x,double *X,double *Y,int Nbase,int Nint)
{
    TSpline *Spline;
    double *y;
    y=new double[Nint];

    Spline=new TSpline;
    Spline->MakeLinearSpline(X,Y,Nbase);
    y=Spline->Interpolate(x,Nint);

    delete Spline;

    return y;
}
//---------------------------------------------------------------------------
int TBeamSolver::CreateGeometry()
{
	for (int i = 0; i < StructPar.NSections; i++) {
		StructPar.Sections[0].Frequency*=1e6;
        StructPar.Sections[0].Power*=1e6;
	}
   /*	F0*=1e6;
	P0*=1e6;    */
    double theta=0;
    double *X_base,*B_base,*E_base,*Al_base,*A_base;
	double *X_int,*B_int,*E_int,*Al_int,*A_int;
	AnsiString S;

    bool Solenoid_success=false;

	int Njmp=0,k0=0;

	Npoints=0;
	for(int i=0;i<StructPar.NElements;i++){
		Npoints+=StructPar.Cells[i].Mesh;
		if (StructPar.Cells[i].First){
			Npoints++;
			Njmp++;
		}
    }

   //	Npoints=Ncells*Nmesh+Njmp;//add+1 for the last point;
	TSplineType Spl;

	X_base = new double[StructPar.NElements]; X_int=new double[Npoints];
	B_base = new double[StructPar.NElements]; B_int=new double[Npoints];
	E_base = new double[StructPar.NElements]; E_int=new double[Npoints];
	Al_base = new double[StructPar.NElements]; Al_int=new double[Npoints];

	delete[] Structure;

	double z=0,zm=0,D=0,x=0,lmb=0;

    Structure=new TStructure[Npoints];

    int k=0;
	for (int i=0;i<StructPar.NElements;i++){
        int Extra=0;

		if (i==StructPar.NElements-1)
            Extra=1;
		else if (StructPar.Cells[i+1].First)
            Extra=1;

		if (StructPar.Cells[i].First)
            z-=zm;

        double lmb=1;
		if (StructPar.Cells[i].Drift){
			D=StructPar.Cells[i].betta;
            bool isInput=false;
            for (int j=i;j<StructPar.NElements;j++){
				if (!StructPar.Cells[j].Drift){
					StructPar.Cells[i].betta=StructPar.Cells[j].betta;
					lmb=c/StructPar.Cells[j].F0;
                    isInput=true;
                    break;
                }
            }
            if (!isInput){
                for (int j=i;j>=0;j--){
					if (!StructPar.Cells[j].Drift){
						StructPar.Cells[i].betta=StructPar.Cells[j].betta;
						lmb=c/StructPar.Cells[j].F0;
                        isInput=true;
                        break;
                    }
                }
            }
            if (!isInput){
				StructPar.Cells[i].betta=1;
                lmb=1;
            }
        }else{
			lmb=c/StructPar.Cells[i].F0;
			theta=StructPar.Cells[i].Mode*pi/180;
			D=StructPar.Cells[i].betta*lmb*theta/(2*pi);
        }
        x+=D/2;
        X_base[i]=x/lmb;
		x+=D/2;
		B_base[i]=StructPar.Cells[i].betta;
		E_base[i]=StructPar.Cells[i].ELP;
		Al_base[i]=StructPar.Cells[i].AL32;
		//zm=D/Nmesh;
		zm=D/StructPar.Cells[i].Mesh;
		k0=k;
		Structure[k].dF=StructPar.Cells[i].dF;

		for (int j=0;j<StructPar.Cells[i].Mesh+Extra;j++){
            X_int[k]=z/lmb;
            Structure[k].ksi=z/lmb;
            Structure[k].lmb=lmb;
			Structure[k].P=StructPar.Cells[i].P0;
            Structure[k].dF=0;
			Structure[k].drift=StructPar.Cells[i].Drift;
			if (StructPar.Cells[i].Drift)
				Structure[k].Ra=StructPar.Cells[i].AkL/lmb;
            else
				Structure[k].Ra=StructPar.Cells[i].AkL;//*lmb;
            Structure[k].jump=false;
			Structure[k].CellNumber=i;
			Structure[k].Dump=false;
			z+=zm;
            k++;
        }
		if (StructPar.Cells[i].First)
			Structure[k0].jump=true;
		if (StructPar.Cells[i].Dump){
			Structure[k0].Dump=true;
			Structure[k0].DumpParameters=StructPar.Cells[i].DumpParameters;
		  //	strcpy(Structure[k0].DumpParameters.File, Cells[i].DumpParameters.File);
		}
	}
	if (StructPar.Cells[StructPar.NElements].Dump){
		Structure[k-1].Dump=true;  //was k0+Nmesh
		Structure[k-1].DumpParameters=StructPar.Cells[StructPar.NElements].DumpParameters; //was k0+Nmesh
	}

	//   int Njmp=0;
//  Structure[0].jump=true;

    double *Xo=NULL, *Bo=NULL, *Eo=NULL, *Ao=NULL;
	double *Xi=NULL, *Bi=NULL, *Ei=NULL, *Ai=NULL;
    int Ncls=0;
    int Npts=0;

    Njmp=0;
    int iJmp=0;

    bool EndOfBlock=false;

  /*    FILE *F;
    F=fopen("cells.log","w");*/

	for (int i=0;i<=StructPar.NElements;i++){
		if (i==StructPar.NElements)
			EndOfBlock=true;
		else if (StructPar.Cells[i].First && i!=0)
            EndOfBlock=true;
        else
            EndOfBlock=false;

        if (EndOfBlock/*Cells[i].First && i!=0 || i==Ncells*/){
			Ncls=i-Njmp;
			Npts=0;
			for (int j=Njmp;j<i;j++) {
				Npts+=StructPar.Cells[j].Mesh;
			}
			Npts++;
			//int Npts0=Ncls*Nmesh+1;

			/*if (i!=Ncells)
				Structure[i*Nmesh].jump=true;*/

            Xo=new double[Ncls];
            Bo=new double[Ncls];
            Eo=new double[Ncls];
            Ao=new double[Ncls];
            Xi=new double[Npts];

			for (int j=0;j<Ncls;j++){
                Xo[j]=X_base[Njmp+j];
                Bo[j]=B_base[Njmp+j];
                Eo[j]=E_base[Njmp+j];
                Ao[j]=Al_base[Njmp+j];
            }

			int pos=0;
			for (int j=0;j<Njmp;j++)
				pos+=StructPar.Cells[j].Mesh;

			for (int j=0;j<Npts;j++)
				Xi[j]=X_int[/*Njmp*Nmesh*/pos+iJmp+j];

            Spl=(Ncls<4)?LSPLINE:SplineType;

            if (Ncls==1)
                Spl=ZSPLINE;

            switch (Spl) {
                case ZSPLINE:{
                    Bi=new double[Npts];
                    Ei=new double[Npts];
                    Ai=new double[Npts];
                    for (int j=0;j<Npts;j++){
                        Bi[j]=Bo[0];
                        Ei[j]=Eo[0];
                        Ai[j]=Ao[0];
                    }
                    break;
                }
                case(LSPLINE):{
                    Bi=LinearInterpolation(Xi,Xo,Bo,Ncls,Npts);
                    Ei=LinearInterpolation(Xi,Xo,Eo,Ncls,Npts);
                    Ai=LinearInterpolation(Xi,Xo,Ao,Ncls,Npts);
                    break;
                }
                case(CSPLINE):{
                    Bi=SplineInterpolation(Xi,Xo,Bo,Ncls,Npts);
                    Ei=SplineInterpolation(Xi,Xo,Eo,Ncls,Npts);
                    Ai=SplineInterpolation(Xi,Xo,Ao,Ncls,Npts);
                    break;
                }
                case(SSPLINE):{
                    Bi=SmoothInterpolation(Xi,Xo,Bo,Ncls,Npts,Smooth);
                    Ei=SmoothInterpolation(Xi,Xo,Eo,Ncls,Npts,Smooth);
                    Ai=SmoothInterpolation(Xi,Xo,Ao,Ncls,Npts,Smooth);
                    break;
                }
            }

            for (int j=0;j<Npts;j++){
				B_int[/*Njmp*Nmesh*/pos+iJmp+j]=Bi[j];
				E_int[/*Njmp*Nmesh*/pos+iJmp+j]=Ei[j];
				Al_int[/*Njmp*Nmesh*/pos+iJmp+j]=Ai[j];
			}


        /*  for (int i=0;i<Npts;i++){
                fprintf(F,"%i %f %f\n",Njmp*Nmesh+i,Xi[i],Ei[i]);
            }     */
            

            delete[] Xo;
            delete[] Xi;
            delete[] Bo;
            delete[] Bi;
			delete[] Eo;
			delete[] Ei;
            delete[] Ao;
			delete[] Ai;

			Njmp=i;
			iJmp++;
		}

	}
	// fclose(F);

	if (StructPar.SolenoidPar.ImportType==IMPORT_1D) {
		int NSol=0;
		double *Xz=NULL;
		double *Bz=NULL;

		NSol=GetSolenoidPoints();
		if(NSol<1){
			StructPar.SolenoidPar.BField=0;
			StructPar.SolenoidPar.Length=0;
			StructPar.SolenoidPar.StartPos=0;
			StructPar.SolenoidPar.ImportType==NO_ELEMENT;
			/*Zmag=0;
			B0=0;
			Lmag=0;
			FSolenoid=false;  */
			S="The format of "+StructPar.SolenoidPar.File+" is wrong or too few points available";
			ShowError(S);
		} else {
			Xz=new double[NSol];
			Bz=new double[NSol];

			ReadSolenoid(NSol,Xz,Bz);
			if (NSol==1) {
				StructPar.SolenoidPar.StartPos=0;
				StructPar.SolenoidPar.Length=Structure[Npoints-1].ksi*Structure[Npoints-1].lmb;
				StructPar.SolenoidPar.BField=Bz[0];
				StructPar.SolenoidPar.ImportType==ANALYTIC_0D;
				/*Zmag=0;
				Lmag=Structure[Npoints-1].ksi*Structure[Npoints-1].lmb;
				B0=Bz[0];
				FSolenoid=false;*/
                delete[] Xz;
                delete[] Bz;
            } else{
                Xi=new double[Npoints];
				for (int i=0; i<Npoints; i++)
                    Xi[i]=Structure[i].ksi*Structure[i].lmb;

                Bi=LinearInterpolation(Xi,Xz,Bz,NSol,Npoints);
                delete[] Xz;
                delete[] Bz;
                delete[] Xi;
            }
        }
    }

	for (int i=0;i<Npoints;i++){
        //int s=0;
		double lmb=Structure[i].lmb;
		if (B_int[i]!=1)
			Structure[i].betta=B_int[i];
		else
            Structure[i].betta=MeVToVelocity(EnergyLimit);

        Structure[i].E=E_int[i];
        Structure[i].A=Structure[i].P>0?E_int[i]*sqrt(Structure[i].P)/We0:0;
/*      if (i==20)
            s=1;*/
        Structure[i].Rp=sqr(E_int[i])/2;;
        Structure[i].B=Structure[i].Rp/(2*We0);
		Structure[i].alpha=Al_int[i]/(lmb*sqrt(lmb));
		switch (StructPar.SolenoidPar.ImportType) {
			case IMPORT_1D:{
				Structure[i].B_ext=Bi[i];
				break;
			}
			case ANALYTIC_0D:{
				if (Structure[i].ksi>=StructPar.SolenoidPar.StartPos/lmb && Structure[i].ksi<=(StructPar.SolenoidPar.StartPos+StructPar.SolenoidPar.Length)/lmb)
					Structure[i].B_ext=StructPar.SolenoidPar.BField;
				else
					Structure[i].B_ext=0;
				break;
			}
			default: {}	;
		}
    }

	if (StructPar.SolenoidPar.ImportType==IMPORT_1D)
		delete[] Bi;

    delete[] X_base; delete[] X_int;
    delete[] B_base; delete[] B_int;
    delete[] E_base; delete[] E_int;
    delete[] Al_base; delete[] Al_int;

    return ERR_NO;
}
//---------------------------------------------------------------------------
TError TBeamSolver::CreateBeam()
{
    double sx=0,sy=0,r=0;
	double b0=0,db=0;

	AnsiString S;

	//Npoints=Ncells*Nmesh;

	//Np=BeamPar.NParticles;

	//OLD CODE
   /* if (BeamType!=RANDOM){
	    if (NpFromFile)
		    Np=Beam[0]->CountCSTParticles(BeamFile);
        if(Np<0) {
            return ERR_CURRENT;
		}
    }

	if (NpEnergy != 0) {
	    if (NpEnergy != Np) { 
            return ERR_NUMBPARTICLE;
		}
	} */

   for (int i=0;i<Np_beam;i++){
        delete Beam[i];
    }
    delete[] Beam;

    Beam=new TBeam*[Npoints];
    for (int i=0;i<Npoints;i++){
		Beam[i]=new TBeam(BeamPar.NParticles);
        Beam[i]->SetBarsNumber(Nbars);
        Beam[i]->SetKernel(Kernel);
        Beam[i]->lmb=Structure[i].lmb;
        Beam[i]->I0=BeamPar.Current;
		Beam[i]->Reverse=StructPar.Reverse;
        //Beam[i]->Cmag=c*Cmag/(Structure[i].lmb*We0); //Cmag = c*B*lmb/Wo * (1/lmb^2 from r normalization)
		for (int j=0;j<BeamPar.NParticles;j++){
            Beam[i]->Particle[j].lost=LIVE;
            Beam[i]->Particle[j].betta=0;
            Beam[i]->Particle[j].Bx=0;
            Beam[i]->Particle[j].phi=0;
            Beam[i]->Particle[j].Bth=0;
            Beam[i]->Particle[j].x=0;
            Beam[i]->Particle[j].x0=0;
            Beam[i]->Particle[j].Th=0;
        }
    }
	Beam[0]->Ib=BeamPar.Current;
	Np_beam=Npoints;
    
	for (int i=0;i<BeamPar.NParticles;i++)
        Beam[0]->Particle[i].z=Structure[0].ksi*Structure[0].lmb;

	//Create Distributions:

	if (!IsFullFileKeyWord(BeamPar.RBeamType)){
		switch (BeamPar.ZBeamType){
			case NORM_2D: {
				Beam[0]->GenerateEnergy(BeamPar.WNorm);
				Beam[0]->GeneratePhase(BeamPar.ZNorm);
				break;
			}
			case FILE_1D: {
				Beam[0]->GeneratePhase(BeamPar.ZNorm);
			}
			case FILE_2D: {
				if (!Beam[0]->ImportEnergy(&BeamPar))
					return ERR_BEAM;
				break;
			}
			default: {
				S="Unexpected Distribution Type";
				ShowError(S);
				return ERR_BEAM;
			}
		}
	}

	switch (BeamPar.RBeamType) {
		case CST_PID:{
			Beam[0]->GeneratePhase(BeamPar.ZNorm);
		}
		case CST_PIT:{
			if (!Beam[0]->BeamFromCST(&BeamPar))
				return ERR_BEAM;
			break;
		}
		case TWISS_2D:{}
		case TWISS_4D:{
			Beam[0]->BeamFromTwiss(&BeamPar);
			break;;
		}
		case SPH_2D:{
			Beam[0]->BeamFromSphere(&BeamPar);
			break;
		}
		case ELL_2D:{
			Beam[0]->BeamFromEllipse(&BeamPar);
			break;
		}
		case FILE_2D: {
			TGauss A;
			A.mean=0;
			A.limit=pi;
			A.sigma=100*pi;
			Beam[0]->GenerateAzimuth(A);
		}
		case TWO_FILES_2D: { }
		case FILE_4D:{
			if (!Beam[0]->BeamFromFile(&BeamPar))
				return ERR_BEAM;
			break;
		}
		default: {
			S="Unexpected Distribution Type";
			ShowError(S);
			return ERR_BEAM;
		}
	}

   //OLD CODE
/*
	if (NpEnergy == 0) {
        if (W_Eq) {
            Beam[0]->MakeEquiprobableDistribution(W0,dW,BETTA_PAR);
        } else {
            Beam[0]->MakeGaussDistribution(W0,dW,BETTA_PAR);
        }
	} else {
		LoadEnergyFromFile(EnergyFile,NpEnergy);
	}

    for (int i=0;i<Np;i++) {
        Beam[0]->Particle[i].betta=MeVToVelocity(Beam[0]->Particle[i].betta);
    }

    if (Phi_Eq) { 
        Beam[0]->MakeEquiprobableDistribution(HellwegTypes::DegToRad(Phi0)-Structure[0].dF,HellwegTypes::DegToRad(dPhi),PHI_PAR);
    } else {
        Beam[0]->MakeGaussDistribution(HellwegTypes::DegToRad(Phi0)-Structure[0].dF,HellwegTypes::DegToRad(dPhi),PHI_PAR);
    }

	if (BeamType==RANDOM) {
		Beam[0]->MakeGaussEmittance(AlphaCS,BettaCS,EmittanceCS);
    } else {
		Beam[0]->ReadCSTEmittance(BeamFile,Np);
	}

   //	if (BeamType!=CST_Y) {  //not used yet
        Beam[0]->MakeEquiprobableDistribution(pi,pi,TH_PAR);
   //	}
    Beam[0]->MakeEquiprobableDistribution(0,0,BTH_PAR);

    for (int i=0;i<Npoints;i++){
        for (int j=0;j<Np;j++) {
            Beam[i]->Particle[j].x0=Beam[0]->Particle[j].x;
        }
	}    */
    
 /* for (int i=0;i<Np;i++){
        Beam[0]->Particle[i].x=0;//-0.001+0.002*i/(Np-1);
        //Beam[0]->Particle[i].phi=0;
        Beam[0]->Particle[i].Bx=0;
        Beam[0]->Particle[i].Th=0;
        Beam[0]->Particle[i].Bth=0;

      //    Beam[0]->Particle[i].phi=DegToRad(-90+i);
       //   Beam[0]->Particle[i].betta=MeVToVelocity(0.05);
    }           */
    return ERR_NO;
}
//---------------------------------------------------------------------------
//MOVED TO BEAM.CPP
/*bool TBeamSolver::LoadEnergyFromFile(AnsiString &F, int NpEnergy)
{
	std::ifstream fs(F.c_str());
	float enrg=0;
	int i=0, np=0;
	bool Success=false;
	AnsiString S,L;

	while (!fs.eof()){
		L=GetLine(fs);

		if (NumWords(L)==2){       //Check if only two numbers in the line
			try {                  //Check if the data is really a number
				S=ReadWord(L,1);
				np=S.ToInt();
				S=ReadWord(L,2);
				enrg=S.ToDouble();
			}
			catch (...){
				continue;          //Skip incorrect line
			}
			if (i==NpEnergy){     //if there is more data than expected
				i++;
				break;
			}
			Beam[0]->Particle[i].betta=enrg;
			i++;
		}
	}

	fs.close();

	Success=(i==NpEnergy);
	return Success;
}       */
//---------------------------------------------------------------------------
int TBeamSolver::GetSolenoidPoints()
{
	return NumPointsInFile(StructPar.SolenoidPar.File,2);
}
//---------------------------------------------------------------------------
bool TBeamSolver::ReadSolenoid(int Nz,double *Z,double* B)
{
	std::ifstream fs(StructPar.SolenoidPar.File.c_str());
	float z=0,Bz=0;
	int i=0;
	bool Success=false;
	AnsiString S,L;

	while (!fs.eof()){
		L=GetLine(fs);

		if (NumWords(L)==2){       //Check if only two numbers in the line
			try {                  //Check if the data is really a number
				S=ReadWord(L,1);
				z=S.ToDouble()/100; //[cm]
				S=ReadWord(L,2);
				Bz=S.ToDouble()/10000;  //[Gs]
			}
			catch (...){
				continue;          //Skip incorrect line
			}
			if (i==Nz){  //if there is more data than expected
				i++;
				break;
			}
			Z[i]=z;
			B[i]=Bz;
			i++;
		}
	}

	fs.close();

	Success=(i==Nz);
	return Success;
}
//---------------------------------------------------------------------------
void TBeamSolver::GetEllipticParameters(int Nknot, double& x0,double& y0, double& a,double& b,double& phi,double &Rx,double& Ry)
{
    Beam[Nknot]->GetEllipticParameters(x0,y0,a,b,phi,Rx,Ry);
}
//---------------------------------------------------------------------------
void TBeamSolver::GetCourantSneider(int Nknot, double& alpha,double& betta, double& epsilon)
{
    Beam[Nknot]->GetCourantSneider(alpha,betta,epsilon);
}
//---------------------------------------------------------------------------
TSpectrumBar *TBeamSolver::GetEnergySpectrum(int Nknot,double& Wav,double& dW)
{
    TSpectrumBar *Spectrum;
    Spectrum=GetEnergySpectrum(Nknot,false,Wav,dW);
    return Spectrum;
}
//---------------------------------------------------------------------------
TSpectrumBar *TBeamSolver::GetPhaseSpectrum(int Nknot,double& Fav,double& dF)
{
    TSpectrumBar *Spectrum;
    Spectrum=GetPhaseSpectrum(Nknot,false,Fav,dF);
    return Spectrum;
}
//---------------------------------------------------------------------------
TSpectrumBar *TBeamSolver::GetEnergySpectrum(int Nknot,bool Env,double& Wav,double& dW)
{
    TSpectrumBar *Spectrum;
    Spectrum=Beam[Nknot]->GetEnergySpectrum(Env,Wav,dW);
    return Spectrum;
}
//---------------------------------------------------------------------------
TSpectrumBar *TBeamSolver::GetPhaseSpectrum(int Nknot,bool Env,double& Fav,double& dF)
{
    TSpectrumBar *Spectrum;
    Spectrum=Beam[Nknot]->GetPhaseSpectrum(Env,Fav,dF);
    return Spectrum;
}
//---------------------------------------------------------------------------
void TBeamSolver::GetBeamParameters(int Nknot,double *X,TBeamParameter Par)
{
    Beam[Nknot]->GetParameters(X,Par);
}
//---------------------------------------------------------------------------
double TBeamSolver::GetKernel()
{
    return Beam[0]->h;
}
//---------------------------------------------------------------------------
void TBeamSolver::GetStructureParameters(double *X,TStructureParameter Par)
{
    switch (Par) {
        case (KSI_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].ksi;
            break;
        }
        case (Z_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].ksi*Structure[i].lmb;
            break;
        }
        case (A_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].A;
            break;
        }
        case (RP_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].Rp;
            break;
        }
        case (B_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].A*We0/Structure[i].lmb;
            break;
        }
        case (ALPHA_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].alpha;
            break;
        }
        case (BETTA_F_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].betta;
            break;
        }
        case (RA_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].Ra*Structure[i].lmb;
            break;
        }
        case (B_EXT_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].B_ext;
            break;
        }
        case (NUM_PAR):{
            for (int i=0;i<Npoints;i++)
                X[i]=Structure[i].CellNumber;
            break;
        }
    }
}
//---------------------------------------------------------------------------
void TBeamSolver::Abort()
{
    Stop=true;
}

//---------------------------------------------------------------------------
void TBeamSolver::Integrate(int Si, int Sj)
{

	double Rb=0,Lb=0,Fb=0,gamma=1,Mr=0,phic=0,Icur=0,lmb=0;
	int component=0;
    TParticle *Particle=Beam[Si]->Particle;

    phic=Beam[Si]->iGetAveragePhase(Par[Sj],K[Sj]);
    Par[Sj].SumSin=0;
    Par[Sj].SumCos=0;
    Par[Sj].SumSin=Beam[Si]->SinSum(Par[Sj],K[Sj]);
    Par[Sj].SumCos=Beam[Si]->CosSum(Par[Sj],K[Sj]);

    gamma=Beam[Si]->iGetAverageEnergy(Par[Sj],K[Sj]);
    Par[Sj].gamma=gamma;

	Lb=Beam[Si]->iGetBeamLength(Par[Sj],K[Sj],Nslices,false)/2;
	lmb=Beam[Si]->lmb;
    Fb=Lb*2*pi/lmb;

    Rb=Beam[Si]->iGetBeamRadius(Par[Sj],K[Sj],false);
    
	Icur=I;//*Lb/lmb;

    if (Rb==0)
        Mr=0;
    else
        Mr=FormFactor(gamma*Lb/Rb);

    Par[Sj].Bz_ext*=lmb*c/We0;
   //   Par[Sj].Bz_ext*=lmb/(myu0*We0);
    Par[Sj].Br_ext=0;
	if (BeamPar.Magnetized)
        Par[Sj].Cmag=Structure[0].B_ext*lmb*c/We0;
    else
        Par[Sj].Cmag=0;

    double phi=0,r=0;
    double Aqz=0,Aqr=0;

	Par[Sj].Aqz=new double[BeamPar.NParticles];
	Par[Sj].Aqr=new double[BeamPar.NParticles];

	for (int i=0;i<BeamPar.NParticles;i++){
		Par[Sj].Aqz[i]=0;
		Par[Sj].Aqr[i]=0;
		if (Particle[i].lost==LIVE){
			phi=Particle[i].phi+K[Sj][i].phi*Par[Sj].h;
			r=(Particle[i].x+K[Sj][i].r*Par[Sj].h)*lmb;
			double V=mod(sqr(Rb)*Lb);
			double z=(phi-phic)*lmb/(2*pi);
			if (Rb!=0 && Lb!=0){
                switch (BeamPar.SpaceCharge.Type) {
					case SPCH_ELL: {
						//Par[Sj].Aqz=3*lmb*Mr*(phi-phic)*(Icur/Ia)/(sqr(gamma)*sqr(Rb)*Fb);     // old expression
						//Par[Sj].Aqz[i]=kFc*(3*Icur*lmb)*(Mr*z/V);                              // Es; original Hellweg expression
						Par[Sj].Aqz[i]=(-2)*2*kFc*(3*Icur*lmb)*(Mr*z/V);                         // Es; corrected (YuE) expression
						Par[Sj].Aqz[i]*=(lmb/We0);  //A

						//Par[Sj].Aqr=sqr(lmb)*(1-Mr)*r*lmb*(Icur/Ia)/(sqr(gamma)*sqr(Rb)*Lb);   // old expression
						//Par[Sj].Aqr[i]=kFc*(3*Icur*lmb/sqr(gamma))*(0.5*(1-Mr)*r/V);           // E; original Hellweg expression
						Par[Sj].Aqr[i]=2*kFc*(3*Icur*lmb)/gamma*(0.5*(1+Mr)*r/V);                // E; corrected (YuE) expression
						Par[Sj].Aqr[i]*=(lmb/We0);  //A
						/*FILE *Fout;
						if ((i == 0) || (i == 999)) {
							Fout=fopen("yeDebug_SK.log","a");
							fprintf(Fout,"TBeamSolver::Integrate (Coulomb): i=%d, Si=%d, Sj=%d, Rb=%g, Lb=%g, r=%g, z=%g, Aqz[i]=%g, Aqr[i]=%g\n",
								i,Si,Sj,Rb,Lb,r,z,Par[Sj].Aqz[i],Par[Sj].Aqr[i]);
							fclose(Fout);
						} */
						//k1F[i]:=dF_dx(bv[j-1],Beam[i,5,j-1],A[j-1],Btmp,SinSum);
						break;
					}
					case SPCH_GW: {
						Par[Sj].Aqz[i]=kFc*Icur*lmb*GaussIntegration(r,z,Rb,Lb,3);  // E;  (YuE) expression
						Par[Sj].Aqz[i]*=(lmb/We0);                     // A
						Par[Sj].Aqr[i]=kFc*Icur*lmb*GaussIntegration(r,z,Rb,Lb,1);  // E;  (YuE) expression
						Par[Sj].Aqr[i]*=(lmb/We0);                     // A
						/*FILE *Fout;
						if ((i == 0) || (i == 999)) {
							Fout=fopen("yeDebug_GW.log","a");
							fprintf(Fout,"TBeamSolver::Integrate (GWmethod): i=%d, Si=%d, Sj=%d, Rb=%g, Lb=%g, r=%g, z=%g, Aqz[i]=%g, Aqr[i]=%g\n",
								i,Si,Sj,Rb,Lb,r,z,Par[Sj].Aqz[i],Par[Sj].Aqr[i]);
							fclose(Fout);
						}  */
						break;
					}
					case SPCH_NO:{}
					default: {};
				}
			}
		}
	}

	Beam[Si]->Integrate(Par[Sj],K,Sj);
	delete[] Par[Sj].Aqz;
	delete[] Par[Sj].Aqr;
}
//---------------------------------------------------------------------------
 double TBeamSolver::GaussIntegration(double r,double z,double Rb,double Lb,int component)
{
  //MOVED CONSTANTS TO CONST.H!

	double Rb2,Lb2,d,d2,ksi,s,t,func,GInt;
	int i;

	Rb2=sqr(Rb);
	Lb2=sqr(Lb);
	d=pow(Rb2*Lb,1/3);
	d2=sqr(d);
	GInt=0;
	for (int i=0;i<11;i++) {
	    ksi=.5*(psi12[i]+1);
	    s=d2*(1/ksi-1);
	    t=sqr(r)/(Rb2+s)+sqr(z)/(Lb2+s);
		if (t <= 5) {
//           func=sqrt(ksi/((Lb2/d2-1)*ksi+1))/abs(((Rb2/d2-1)*ksi+1));
           func=sqrt(ksi/((Lb2/d2-1)*ksi+1))/((Rb2/d2-1)*ksi+1);
		   if (component < 3) {
//		        GInt +=.5*r*w12[i]*func/abs(((Rb2/d2-1)*ksi+1));
		        GInt +=.5*r*w12[i]*func/((Rb2/d2-1)*ksi+1);
		   }
		   if (component == 3) {
//		        GInt +=.5*z*w12[i]*func/abs(((Lb2/d2-1)*ksi+1));
		        GInt +=.5*z*w12[i]*func/((Lb2/d2-1)*ksi+1);
		   }
		} 
	} 
	return GInt;
}
//---------------------------------------------------------------------------
void TBeamSolver::CountLiving(int Si)
{
    Nliv=Beam[Si]->GetLivingNumber();
    if (Nliv==0){
      /*    FILE *F;
        F=fopen("beam.log","w");
        for (int i=Si;i<Npoints;i++){
            for (int j=0;j<Np;j++)
                fprintf(F,"%i ",Beam[i]->Particle[j].lost);
            fprintf(F,"\n");
        }
        fclose(F);   */
		#ifndef RSLINAC
		AnsiString S="Beam Lost!";
		ShowError(S);
        #endif
        Stop=true;
        return;
    }
}
//---------------------------------------------------------------------------
void TBeamSolver::Step(int Si)
{
    bool drift=false;
	double lmb=Structure[Si].lmb;
    Beam[Si]->lmb=lmb;
	CountLiving(Si);
	I=BeamPar.Current*Nliv/BeamPar.NParticles;
  /*    
    Rb=Beam[i]->GetBeamRadius();
    phi0=Beam[i]->GetAveragePhase();
    dphi=Beam[i]->GetPhaseLength();
    Lb=dphi*lmb/(2*pi);
    betta0=Beam[i]->GetAverageEnergy();

    w=Structure[i]->alpha*lmb;        */
    drift=(Structure[Si].drift);
    for (int i=0;i<4;i++)
        Par[i].drift=Structure[Si].drift;
    //Par[3].drift=Structure[Si+1].drift;

    dh=Structure[Si+1].ksi-Structure[Si].ksi;
    Par[0].h=0;
    Par[1].h=dh/2;
    Par[2].h=Par[1].h;
    Par[3].h=dh;

    double db=Structure[Si+1].betta-Structure[Si].betta;
    Par[0].bw=Structure[Si].betta;
    Par[1].bw=Structure[Si].betta+db/2;
    Par[2].bw=Par[1].bw;
    Par[3].bw=Structure[Si+1].betta;

    double dw=Structure[Si+1].alpha-Structure[Si].alpha;
    Par[0].w=Structure[Si].alpha*lmb;
    Par[1].w=(Structure[Si].alpha+dw/2)*lmb;
    Par[2].w=Par[1].w;
    Par[3].w=Structure[Si+1].alpha*lmb;

    double dE=Structure[Si+1].E-Structure[Si].E;
    Par[0].E=Structure[Si].E;
    Par[1].E=Structure[Si].E+dE/2;
    Par[2].E=Par[1].E;
    Par[3].E=Structure[Si+1].E;

    double dA=Structure[Si+1].A-Structure[Si].A;
    Par[0].A=Structure[Si].A;
    Par[1].A=Structure[Si].A;//+dA/2;
    Par[2].A=Par[1].A;
    Par[3].A=Structure[Si].A;

    double dB=Structure[Si+1].B-Structure[Si].B;
    Par[0].B=Structure[Si].B;
    Par[1].B=Structure[Si].B+dB/2;
    Par[2].B=Par[1].B;
    Par[3].B=Structure[Si+1].B;

   /*   for(int i=0;i<4;i++)
        Par[i].B*=I;  */

    double d2E=0;
    double d2A=0;
    double d2h=0;
    double dR=0;
    if (Structure[Si+1].Rp!=0 && Structure[Si].Rp!=0)
        dR=ln(Structure[Si+1].Rp)-ln(Structure[Si].Rp);
    double d2R=0;

    if (drift){
        for (int i=0;i<4;i++){
            Par[i].dL=0;
            Par[i].dA=0;
        }
    } else {
        if (Si==0 || (Si!=0 && Structure[Si].jump)){
            Par[0].dL=dE/(Structure[Si].E*dh);
            //Par[0].dL=dR/dh;
            Par[0].dA=dA/dh;
        }else{
            d2E=Structure[Si+1].E-Structure[Si-1].E;
            d2A=Structure[Si+1].A-Structure[Si-1].A;
            d2h=Structure[Si+1].ksi-Structure[Si-1].ksi;
            Par[0].dL=d2E/(Structure[Si].E*d2h);
           //   d2R=ln(Structure[Si+1].Rp)-ln(Structure[Si-1].Rp);
           //   Par[0].dL=d2R/d2h;
            Par[0].dA=d2A/d2h;
        }
        Par[1].dL=dE/((Structure[Si].E+dE/2)*dh);
        //Par[1].dL=dR/dh;
        Par[2].dL=Par[1].dL;

        Par[1].dA=dA/dh;
        Par[2].dA=Par[1].dA;

        if (Si==Npoints-2 || (Si<Npoints-2 && Structure[Si+2].jump)){
            Par[3].dL=dE/(Structure[Si+1].E*dh);
            //Par[3].dL=dR/dh;
            Par[3].dA=dA/dh;
        }else{
           //   d2E=Structure[Si+2].E-Structure[Si].E;
            d2A=Structure[Si+2].A-Structure[Si].A;
            d2h=Structure[Si+2].ksi-Structure[Si].ksi;
            Par[3].dL=d2E/(Structure[Si+1].E*d2h);
            //d2R=ln(Structure[Si+2].Rp)-ln(Structure[Si].Rp);
            ///Par[0].dL=d2R/d2h;
            Par[3].dA=d2A/d2h;
        }
    }

    double dBx=Structure[Si+1].B_ext-Structure[Si].B_ext;
    Par[0].Bz_ext=Structure[Si].B_ext;
    Par[1].Bz_ext=Structure[Si].B_ext+dBx/2;
    Par[2].Bz_ext=Par[1].Bz_ext;
    Par[3].Bz_ext=Structure[Si+1].B_ext;

    /*fprintf(logFile,"Phase Radius Betta\n");
    for (int i=0;i<Np;i++)
        fprintf(logFile,"%f %f %f\n",Beam[Si]->Particle[i].phi,Beam[Si]->Particle[i].x,Beam[Si]->Particle[i].betta);

    fclose(logFile);  */

    for (int j=0;j<Ncoef;j++)
        Integrate(Si,j);
}
//---------------------------------------------------------------------------
void TBeamSolver::Solve()
{
	#ifndef RSLINAC
	if (SmartProgress==NULL){
		ShowMessage("System Message: ProgressBar not assigned! Code needs to be corrected");
        return;
    }
    SmartProgress->Reset(Npoints-1/*Np*/);
    #endif

  //    logFile=fopen("beam.log","w");
 /* for (int i=0;i<Np;i++){
      //    fprintf(logFile,"%f %f\n",Beam[0]->Particle[i].x,Beam[0]->Particle[i].x/Structure[0].lmb);
        Beam[0]->Particle[i].x/=Structure[0].lmb;
    }                                             */
 // fclose(logFile);
    
    for (int i=0;i<Ncoef;i++){
        delete[] K[i];
		K[i]=new TIntegration[BeamPar.NParticles];
    }
    K[0][0].A=Structure[0].A;
   //   Beam[0]->Particle[j].z=Structure[0].ksi*Structure[0].lmb;
   //
	for (int i=0;i<Npoints;i++){
        //for (int j=0;j<Np;j++){

            //if (i==0)
           //   Nliv=Beam[i]->GetLivingNumber();

		if (Structure[i].Dump) {
			int jmin=0;
			int jmax=BeamPar.NParticles;
			//char *Fname=(char *)Structure[i].DumpParameters.File;
			std::ofstream fo(Structure[i].DumpParameters.File.c_str());
			AnsiString s;

			if (Structure[i].DumpParameters.N1>0 && Structure[i].DumpParameters.N2==0) {
				jmin=0;
				jmax=Structure[i].DumpParameters.N1;
			} else if (Structure[i].DumpParameters.N1>0 && Structure[i].DumpParameters.N2>0) {
				jmin=Structure[i].DumpParameters.N1-1;
				jmax=Structure[i].DumpParameters.N2;
			}

			if (jmin>BeamPar.NParticles || jmax>BeamPar.NParticles) {
				fo<<"WARNING: The defined range of particle numbers exceeds the number of available particles. The region was set to default.\n";
				jmin=0;
				jmax=BeamPar.NParticles;
			}

			fo<<"List of ";

			if (jmin==0 && jmax==BeamPar.NParticles)
				fo<<"ALL ";
			if (Structure[i].DumpParameters.LiveOnly)
					 fo<<"LIVE ";
			fo<<"particles ";

			if (!(jmin==0 && jmax==BeamPar.NParticles)){
				fo<<" from #";
				fo<<jmin+1;
				fo<<" to #";
				fo<<jmax;

			}
			fo<<" at z=";

			s=s.FormatFloat("#0.00",100*Structure[i].ksi*Structure[i].lmb);
			fo<<s.c_str();
			fo<<" cm\n";

			fo<<"Particle #\t";
			if (!Structure[i].DumpParameters.LiveOnly)
				fo<<"Lost\t";

			if (Structure[i].DumpParameters.Phase)
				fo<<"Phase [deg]\t";
			if (Structure[i].DumpParameters.Energy)
				fo<<"Energy [MeV]\t";
			if (Structure[i].DumpParameters.Radius)
				fo<<"Radius [mm]\t";
			if (Structure[i].DumpParameters.Azimuth)
				fo<<"Azimuth [deg]\t";
			if (Structure[i].DumpParameters.Vx)
				fo<<"Vx	[m/s]\t";
			//fo<<"Vth [m/s]\t";
			fo<<"\n";

			for (int j=jmin;j<jmax;j++){
				if(!Structure[i].DumpParameters.LiveOnly || (Structure[i].DumpParameters.LiveOnly && !Beam[i]->Particle[j].lost)){
					s=s.FormatFloat("#0000\t\t",j+1);
					fo<<s.c_str();
					if (!Structure[i].DumpParameters.LiveOnly) {
						if (Beam[i]->Particle[j].lost)
							fo<<"LOST\t";
						else
                            fo<<"LIVE\t";
					}
					if (Structure[i].DumpParameters.Phase){
						s=s.FormatFloat("#0.00\t\t",HellwegTypes::RadToDeg(Beam[i]->Particle[j].phi));
						fo<<s.c_str();
					}
					if (Structure[i].DumpParameters.Energy){
						s=s.FormatFloat("#0.00\t\t\t",VelocityToMeV(Beam[i]->Particle[j].betta));
						fo<<s.c_str();
					}
					if (Structure[i].DumpParameters.Radius){
						s=s.FormatFloat("#0.00\t\t\t",1000*Beam[i]->Particle[j].x*Structure[i].lmb);
						fo<<s.c_str();
					}
					if (Structure[i].DumpParameters.Azimuth){
						s=s.FormatFloat("#0.00\t\t",HellwegTypes::RadToDeg(Beam[i]->Particle[j].Th));
						fo<<s.c_str();
					}
					if (Structure[i].DumpParameters.Vx){
						s=s.FormatFloat("#0.00\t\t",Beam[i]->Particle[j].Bx*c);
						fo<<s.c_str();
					}
				 /*	s=s.FormatFloat("#0.00\t\t",Beam[i]->Particle[j].Bth*c);
					fo<<s.c_str();  */
					fo<<"\n";
				}
			}    
			fo.close();  
		}

		if (i==Npoints-1) break; // Nowhere to iterate      
		
		if (!Structure[i+1].jump){
			Step(i);
			Structure[i+1].A=Structure[i].A+dh*(K[0][0].A+K[1][0].A+2*K[2][0].A+2*K[3][0].A)/6;
			//  fprintf(logFile,"%f %f %f %f %f\n",K[1][0].A,K[2][0].A,K[3][0].A,K[0][0].A,Structure[i+1].A);
			Beam[i]->Next(Beam[i+1],Par[3],K);
		} else {
			//Structure[i+1].A=Structure[i].A ;
			Beam[i]->Next(Beam[i+1]);
		}

		for (int j=0;j<BeamPar.NParticles;j++){
			if (Beam[i+1]->Particle[j].lost==LIVE && mod(Beam[i+1]->Particle[j].x)>=Structure[i+1].Ra)
				Beam[i+1]->Particle[j].lost=RADIUS_LOST;
            Beam[i+1]->Particle[j].z=Structure[i+1].ksi*Structure[i+1].lmb;
            Beam[i+1]->Particle[j].phi-=Structure[i+1].dF;
		}
		
        #ifndef RSLINAC
        SmartProgress->operator ++();
        Application->ProcessMessages();
        #endif
        if (Stop){
            Stop=false;
			#ifndef RSLINAC
			AnsiString S="Solve Process Aborted!";
			ShowError(S);
			SmartProgress->Reset();
            #endif
            return;
        }
        for (int i=0;i<Ncoef;i++)
            memset(K[i], 0, sizeof(TIntegration));
        //}
    }

   //   

    #ifndef RSLINAC
    SmartProgress->SetPercent(100);
    SmartProgress->SetTime(0);
    #endif
}
//---------------------------------------------------------------------------
#ifndef RSLINAC
TResult TBeamSolver::Output(AnsiString& FileName,TMemo *Memo)
#else
TResult TBeamSolver::Output(AnsiString& FileName)
#endif
{
    AnsiString Line,s;
    TStringList *OutputStrings;
    OutputStrings= new TStringList;
    TResult Result;
  /*    int Nliv=0;
    Nliv=Beam[Npoints-1]->GetLivingNumber();
                     */
    OutputStrings->Clear();
	OutputStrings->Add("========================================");
    OutputStrings->Add("INPUT DATA from:");
	OutputStrings->Add(InputFile);
	OutputStrings->Add("========================================");

  /*    TStringList *InputStrings;
    InputStrings= new TStringList;
	InputStrings->LoadFromFile(InputFile);    */
    OutputStrings->AddStrings(InputStrings);

	OutputStrings->Add("========================================");
    OutputStrings->Add("RESULTS");
	OutputStrings->Add("========================================");
    OutputStrings->Add("");

    double Ws=0;
   //   AnsiString s;
    int j=Npoints-1;
    double z=100*Structure[j].ksi*Structure[j].lmb;

    double W=0,dW=0;

	TSpectrumBar *WSpectrum=GetEnergySpectrum(j,true,W,Ws);
    if (W!=0)
        dW=100*Ws/W;
    else
        dW=100;
	double Wm=Beam[j]->GetMaxEnergy();
	double I=Beam[j]->Ib;
	double I0=Beam[0]->Ib;
    double kc=100.0*Beam[j]->GetLivingNumber()/Beam[0]->GetLivingNumber();
    double r=1e3*Beam[j]->GetBeamRadius();

    double F=0,dF=0;

    TSpectrumBar *FSpectrum=GetPhaseSpectrum(j,true,F,dF);
    double f=1e-6*c/Structure[j].lmb;
	double Ra=1e3*Structure[j].Ra*Structure[j].lmb;
	double P=W*I;

	double W0=Beam[0]->GetAverageEnergy();
	//double Wout=Beam[j]->GetAverageEnergy();
	double Pin=W0*I0;


	double v=Structure[j].betta;
	double E=sqrt(2*Structure[j].Rp);
	double Pb=E!=0?1e-6*sqr(Structure[j].A*We0/E):0;

    /*double Pw=P0;
    for(int i=1;i<Npoints;i++)
        Pw=Pw*exp(-2*(Structure[i].ksi-Structure[i-1].ksi)*Structure[i].alpha*Structure[i].lmb);  */
	//double Pw=1e-6*P0-(P-Pin+Pb);

    double alpha=0,betta=0,eps=0;
	GetCourantSneider(j,alpha,betta,eps);

  /*  double A=0;
  	int Na=j-Nmesh/2;
	if (Na>0)
		A=Structure[Na].A;     */

    Result.Length=z;
    Result.AverageEnergy=W;
    Result.MaximumEnergy=Wm;
	Result.EnergySpectrum=dW;
	Result.InputCurrent=1e3*I0;
    Result.BeamCurrent=1e3*I;
    Result.Captured=kc;
    Result.BeamRadius=r;
    Result.AveragePhase=F;
    Result.PhaseLength=dF;
    Result.BeamPower=P;
    Result.LoadPower=Pb;
    Result.Alpha=alpha;
    Result.Betta=100*betta;
    Result.Emittance=100*eps;
  //  Result.A=A;

	Line="Total Length = "+s.FormatFloat("#0.000",Result.Length)+" cm";
    OutputStrings->Add(Line);
    Line="Average Energy = "+s.FormatFloat("#0.000",Result.AverageEnergy)+" MeV";
    OutputStrings->Add(Line);
    Line="Maximum Energy = "+s.FormatFloat("#0.000",Result.MaximumEnergy)+" MeV";
    OutputStrings->Add(Line);
    Line="Energy Spectrum = "+s.FormatFloat("#0.00",Result.EnergySpectrum)+" %";
    OutputStrings->Add(Line);
    Line="Input Current = "+s.FormatFloat("#0.00",Result.InputCurrent)+" mA";
    OutputStrings->Add(Line);
    Line="Beam Current = "+s.FormatFloat("#0.00",Result.BeamCurrent)+" mA";
    OutputStrings->Add(Line);
    Line="Captured = "+s.FormatFloat("#0.00",Result.Captured)+" %";
    OutputStrings->Add(Line);
    Line="Beam Radius (RMS) = "+s.FormatFloat("#0.00",Result.BeamRadius)+" mm";
    OutputStrings->Add(Line);
    Line="Average Phase = "+s.FormatFloat("#0.00",Result.AveragePhase)+" deg";
	OutputStrings->Add(Line);
	Line="Phase Length = "+s.FormatFloat("#0.00",Result.PhaseLength)+" deg";
	OutputStrings->Add(Line);
	OutputStrings->Add("Twiss Parameters:");
	Line="alpha= "+s.FormatFloat("#0.00000",Result.Alpha);
	OutputStrings->Add(Line);
	Line="betta = "+s.FormatFloat("#0.00000",Result.Betta)+" cm/rad";
	OutputStrings->Add(Line);
	Line="epsilon = "+s.FormatFloat("#0.000000",Result.Emittance)+" cm*rad";
	OutputStrings->Add(Line);
	//OutputStrings->Add("========================================");

	int Nsec=0;
	double Pbeam0=0, Wb0=0;
	double Ib=0, Wb=0, P0=0;
	for (int i=0;i<=j;i++){
		if (Structure[i].jump && !Structure[i].drift || i==j) {
			Ib=Beam[i]->Ib;
			Wb=Beam[i]->GetAverageEnergy();

			if (Nsec>0) {
				double Pload=E!=0?1e-6*sqr(Structure[i-1].A*We0/E):0;
				double Pbeam=Ib*Wb;

				Line="===========Section #"+s.FormatFloat("#",Nsec)+" ======================";
				OutputStrings->Add(Line);
				Line="Input Power = "+s.FormatFloat("#0.0000",P0)+" MW";
				OutputStrings->Add(Line);
			   /*	Line="Beam Power = "+s.FormatFloat("#0.0000",Pbeam)+" MW";
				OutputStrings->Add(Line);
				Line="Beam Energy = "+s.FormatFloat("#0.0000",Wb)+" MeV";
				OutputStrings->Add(Line);   */
				Line="Beam Energy Gain = "+s.FormatFloat("#0.0000",Wb-Wb0)+" MeV";
				OutputStrings->Add(Line);
				Line="Beam Power Gain = "+s.FormatFloat("#0.0000",Pbeam-Pbeam0)+" MW";
				OutputStrings->Add(Line);
				Line="Load Power = "+s.FormatFloat("#0.0000",Pload)+" MW";
				OutputStrings->Add(Line);
				Line="Loss Power = "+s.FormatFloat("#0.0000",P0-(Pbeam-Pbeam0+Pload))+" MW";
				OutputStrings->Add(Line);
			}

			Pbeam0=Ib*Wb;
			P0=1e-6*Structure[i].P;
			Wb0=Wb;
			Nsec++;
		}
	}
	OutputStrings->Add("========================================");


    #ifndef RSLINAC
    if (Memo!=NULL){
        Memo->Lines->AddStrings(OutputStrings);
    }
    #endif
                       
    delete[] WSpectrum;
    delete[] FSpectrum;  
    OutputStrings->SaveToFile(FileName);
    delete OutputStrings;
   //   delete Strings;

    

    return Result;
}
//---------------------------------------------------------------------------
#pragma package(smart_init)
